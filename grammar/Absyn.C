//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   PDefs    ********************/
PDefs::PDefs(ListDef *p1)
{
  listdef_ = p1;

}

PDefs::PDefs(const PDefs & other)
{
  listdef_ = other.listdef_->clone();

}

PDefs &PDefs::operator=(const PDefs & other)
{
  PDefs tmp(other);
  swap(tmp);
  return *this;
}

void PDefs::swap(PDefs & other)
{
  std::swap(listdef_, other.listdef_);

}

PDefs::~PDefs()
{
  delete(listdef_);

}

void PDefs::accept(Visitor *v)
{
  v->visitPDefs(this);
}

PDefs *PDefs::clone() const
{
  return new PDefs(*this);
}



/********************   DefImport    ********************/
DefImport::DefImport(ListPackageName *p1)
{
  listpackagename_ = p1;

}

DefImport::DefImport(const DefImport & other)
{
  listpackagename_ = other.listpackagename_->clone();

}

DefImport &DefImport::operator=(const DefImport & other)
{
  DefImport tmp(other);
  swap(tmp);
  return *this;
}

void DefImport::swap(DefImport & other)
{
  std::swap(listpackagename_, other.listpackagename_);

}

DefImport::~DefImport()
{
  delete(listpackagename_);

}

void DefImport::accept(Visitor *v)
{
  v->visitDefImport(this);
}

DefImport *DefImport::clone() const
{
  return new DefImport(*this);
}



/********************   DefPackage    ********************/
DefPackage::DefPackage(ListPackageName *p1)
{
  listpackagename_ = p1;

}

DefPackage::DefPackage(const DefPackage & other)
{
  listpackagename_ = other.listpackagename_->clone();

}

DefPackage &DefPackage::operator=(const DefPackage & other)
{
  DefPackage tmp(other);
  swap(tmp);
  return *this;
}

void DefPackage::swap(DefPackage & other)
{
  std::swap(listpackagename_, other.listpackagename_);

}

DefPackage::~DefPackage()
{
  delete(listpackagename_);

}

void DefPackage::accept(Visitor *v)
{
  v->visitDefPackage(this);
}

DefPackage *DefPackage::clone() const
{
  return new DefPackage(*this);
}



/********************   DefModule    ********************/
DefModule::DefModule(Id p1, MetaParamDecl *p2, ListModDef *p3)
{
  id_ = p1;
  metaparamdecl_ = p2;
  listmoddef_ = p3;

}

DefModule::DefModule(const DefModule & other)
{
  id_ = other.id_;
  metaparamdecl_ = other.metaparamdecl_->clone();
  listmoddef_ = other.listmoddef_->clone();

}

DefModule &DefModule::operator=(const DefModule & other)
{
  DefModule tmp(other);
  swap(tmp);
  return *this;
}

void DefModule::swap(DefModule & other)
{
  std::swap(id_, other.id_);
  std::swap(metaparamdecl_, other.metaparamdecl_);
  std::swap(listmoddef_, other.listmoddef_);

}

DefModule::~DefModule()
{
  delete(metaparamdecl_);
  delete(listmoddef_);

}

void DefModule::accept(Visitor *v)
{
  v->visitDefModule(this);
}

DefModule *DefModule::clone() const
{
  return new DefModule(*this);
}



/********************   DefStruct    ********************/
DefStruct::DefStruct(Id p1, MetaParamDecl *p2, ListStructDef *p3)
{
  id_ = p1;
  metaparamdecl_ = p2;
  liststructdef_ = p3;

}

DefStruct::DefStruct(const DefStruct & other)
{
  id_ = other.id_;
  metaparamdecl_ = other.metaparamdecl_->clone();
  liststructdef_ = other.liststructdef_->clone();

}

DefStruct &DefStruct::operator=(const DefStruct & other)
{
  DefStruct tmp(other);
  swap(tmp);
  return *this;
}

void DefStruct::swap(DefStruct & other)
{
  std::swap(id_, other.id_);
  std::swap(metaparamdecl_, other.metaparamdecl_);
  std::swap(liststructdef_, other.liststructdef_);

}

DefStruct::~DefStruct()
{
  delete(metaparamdecl_);
  delete(liststructdef_);

}

void DefStruct::accept(Visitor *v)
{
  v->visitDefStruct(this);
}

DefStruct *DefStruct::clone() const
{
  return new DefStruct(*this);
}



/********************   NoParams    ********************/
NoParams::NoParams()
{

}

NoParams::NoParams(const NoParams & other)
{

}

NoParams &NoParams::operator=(const NoParams & other)
{
  NoParams tmp(other);
  swap(tmp);
  return *this;
}

void NoParams::swap(NoParams & other)
{

}

NoParams::~NoParams()
{

}

void NoParams::accept(Visitor *v)
{
  v->visitNoParams(this);
}

NoParams *NoParams::clone() const
{
  return new NoParams(*this);
}



/********************   SomeParams    ********************/
SomeParams::SomeParams(ListMetaParam *p1)
{
  listmetaparam_ = p1;

}

SomeParams::SomeParams(const SomeParams & other)
{
  listmetaparam_ = other.listmetaparam_->clone();

}

SomeParams &SomeParams::operator=(const SomeParams & other)
{
  SomeParams tmp(other);
  swap(tmp);
  return *this;
}

void SomeParams::swap(SomeParams & other)
{
  std::swap(listmetaparam_, other.listmetaparam_);

}

SomeParams::~SomeParams()
{
  delete(listmetaparam_);

}

void SomeParams::accept(Visitor *v)
{
  v->visitSomeParams(this);
}

SomeParams *SomeParams::clone() const
{
  return new SomeParams(*this);
}



/********************   EqExp    ********************/
EqExp::EqExp(Exp *p1)
{
  exp_ = p1;

}

EqExp::EqExp(const EqExp & other)
{
  exp_ = other.exp_->clone();

}

EqExp &EqExp::operator=(const EqExp & other)
{
  EqExp tmp(other);
  swap(tmp);
  return *this;
}

void EqExp::swap(EqExp & other)
{
  std::swap(exp_, other.exp_);

}

EqExp::~EqExp()
{
  delete(exp_);

}

void EqExp::accept(Visitor *v)
{
  v->visitEqExp(this);
}

EqExp *EqExp::clone() const
{
  return new EqExp(*this);
}



/********************   NoEqExp    ********************/
NoEqExp::NoEqExp()
{

}

NoEqExp::NoEqExp(const NoEqExp & other)
{

}

NoEqExp &NoEqExp::operator=(const NoEqExp & other)
{
  NoEqExp tmp(other);
  swap(tmp);
  return *this;
}

void NoEqExp::swap(NoEqExp & other)
{

}

NoEqExp::~NoEqExp()
{

}

void NoEqExp::accept(Visitor *v)
{
  v->visitNoEqExp(this);
}

NoEqExp *NoEqExp::clone() const
{
  return new NoEqExp(*this);
}



/********************   MetaParam1    ********************/
MetaParam1::MetaParam1(Type *p1, Id p2, OptionalEqExp *p3)
{
  type_ = p1;
  id_ = p2;
  optionaleqexp_ = p3;

}

MetaParam1::MetaParam1(const MetaParam1 & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;
  optionaleqexp_ = other.optionaleqexp_->clone();

}

MetaParam1 &MetaParam1::operator=(const MetaParam1 & other)
{
  MetaParam1 tmp(other);
  swap(tmp);
  return *this;
}

void MetaParam1::swap(MetaParam1 & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);
  std::swap(optionaleqexp_, other.optionaleqexp_);

}

MetaParam1::~MetaParam1()
{
  delete(type_);
  delete(optionaleqexp_);

}

void MetaParam1::accept(Visitor *v)
{
  v->visitMetaParam1(this);
}

MetaParam1 *MetaParam1::clone() const
{
  return new MetaParam1(*this);
}



/********************   DefConst    ********************/
DefConst::DefConst(Type *p1, Id p2, OptionalEqExp *p3)
{
  type_ = p1;
  id_ = p2;
  optionaleqexp_ = p3;

}

DefConst::DefConst(const DefConst & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;
  optionaleqexp_ = other.optionaleqexp_->clone();

}

DefConst &DefConst::operator=(const DefConst & other)
{
  DefConst tmp(other);
  swap(tmp);
  return *this;
}

void DefConst::swap(DefConst & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);
  std::swap(optionaleqexp_, other.optionaleqexp_);

}

DefConst::~DefConst()
{
  delete(type_);
  delete(optionaleqexp_);

}

void DefConst::accept(Visitor *v)
{
  v->visitDefConst(this);
}

DefConst *DefConst::clone() const
{
  return new DefConst(*this);
}



/********************   DefReg    ********************/
DefReg::DefReg(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

DefReg::DefReg(const DefReg & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

DefReg &DefReg::operator=(const DefReg & other)
{
  DefReg tmp(other);
  swap(tmp);
  return *this;
}

void DefReg::swap(DefReg & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

DefReg::~DefReg()
{
  delete(type_);

}

void DefReg::accept(Visitor *v)
{
  v->visitDefReg(this);
}

DefReg *DefReg::clone() const
{
  return new DefReg(*this);
}



/********************   DefMem    ********************/
DefMem::DefMem(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

DefMem::DefMem(const DefMem & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

DefMem &DefMem::operator=(const DefMem & other)
{
  DefMem tmp(other);
  swap(tmp);
  return *this;
}

void DefMem::swap(DefMem & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

DefMem::~DefMem()
{
  delete(type_);

}

void DefMem::accept(Visitor *v)
{
  v->visitDefMem(this);
}

DefMem *DefMem::clone() const
{
  return new DefMem(*this);
}



/********************   DefSubmodule    ********************/
DefSubmodule::DefSubmodule(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

DefSubmodule::DefSubmodule(const DefSubmodule & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

DefSubmodule &DefSubmodule::operator=(const DefSubmodule & other)
{
  DefSubmodule tmp(other);
  swap(tmp);
  return *this;
}

void DefSubmodule::swap(DefSubmodule & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

DefSubmodule::~DefSubmodule()
{
  delete(type_);

}

void DefSubmodule::accept(Visitor *v)
{
  v->visitDefSubmodule(this);
}

DefSubmodule *DefSubmodule::clone() const
{
  return new DefSubmodule(*this);
}



/********************   DefInput    ********************/
DefInput::DefInput(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

DefInput::DefInput(const DefInput & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

DefInput &DefInput::operator=(const DefInput & other)
{
  DefInput tmp(other);
  swap(tmp);
  return *this;
}

void DefInput::swap(DefInput & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

DefInput::~DefInput()
{
  delete(type_);

}

void DefInput::accept(Visitor *v)
{
  v->visitDefInput(this);
}

DefInput *DefInput::clone() const
{
  return new DefInput(*this);
}



/********************   DefOutput    ********************/
DefOutput::DefOutput(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

DefOutput::DefOutput(const DefOutput & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

DefOutput &DefOutput::operator=(const DefOutput & other)
{
  DefOutput tmp(other);
  swap(tmp);
  return *this;
}

void DefOutput::swap(DefOutput & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

DefOutput::~DefOutput()
{
  delete(type_);

}

void DefOutput::accept(Visitor *v)
{
  v->visitDefOutput(this);
}

DefOutput *DefOutput::clone() const
{
  return new DefOutput(*this);
}



/********************   DefInternal    ********************/
DefInternal::DefInternal(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

DefInternal::DefInternal(const DefInternal & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

DefInternal &DefInternal::operator=(const DefInternal & other)
{
  DefInternal tmp(other);
  swap(tmp);
  return *this;
}

void DefInternal::swap(DefInternal & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

DefInternal::~DefInternal()
{
  delete(type_);

}

void DefInternal::accept(Visitor *v)
{
  v->visitDefInternal(this);
}

DefInternal *DefInternal::clone() const
{
  return new DefInternal(*this);
}



/********************   DefEvent    ********************/
DefEvent::DefEvent(EventName *p1, ListEventParam *p2, Block *p3)
{
  eventname_ = p1;
  listeventparam_ = p2;
  block_ = p3;

}

DefEvent::DefEvent(const DefEvent & other)
{
  eventname_ = other.eventname_->clone();
  listeventparam_ = other.listeventparam_->clone();
  block_ = other.block_->clone();

}

DefEvent &DefEvent::operator=(const DefEvent & other)
{
  DefEvent tmp(other);
  swap(tmp);
  return *this;
}

void DefEvent::swap(DefEvent & other)
{
  std::swap(eventname_, other.eventname_);
  std::swap(listeventparam_, other.listeventparam_);
  std::swap(block_, other.block_);

}

DefEvent::~DefEvent()
{
  delete(eventname_);
  delete(listeventparam_);
  delete(block_);

}

void DefEvent::accept(Visitor *v)
{
  v->visitDefEvent(this);
}

DefEvent *DefEvent::clone() const
{
  return new DefEvent(*this);
}



/********************   DefInit    ********************/
DefInit::DefInit(EventName *p1, Block *p2)
{
  eventname_ = p1;
  block_ = p2;

}

DefInit::DefInit(const DefInit & other)
{
  eventname_ = other.eventname_->clone();
  block_ = other.block_->clone();

}

DefInit &DefInit::operator=(const DefInit & other)
{
  DefInit tmp(other);
  swap(tmp);
  return *this;
}

void DefInit::swap(DefInit & other)
{
  std::swap(eventname_, other.eventname_);
  std::swap(block_, other.block_);

}

DefInit::~DefInit()
{
  delete(eventname_);
  delete(block_);

}

void DefInit::accept(Visitor *v)
{
  v->visitDefInit(this);
}

DefInit *DefInit::clone() const
{
  return new DefInit(*this);
}



/********************   DefConnect    ********************/
DefConnect::DefConnect(ChannelSpecifier *p1, ChannelSpecifier *p2)
{
  channelspecifier_1 = p1;
  channelspecifier_2 = p2;

}

DefConnect::DefConnect(const DefConnect & other)
{
  channelspecifier_1 = other.channelspecifier_1->clone();
  channelspecifier_2 = other.channelspecifier_2->clone();

}

DefConnect &DefConnect::operator=(const DefConnect & other)
{
  DefConnect tmp(other);
  swap(tmp);
  return *this;
}

void DefConnect::swap(DefConnect & other)
{
  std::swap(channelspecifier_1, other.channelspecifier_1);
  std::swap(channelspecifier_2, other.channelspecifier_2);

}

DefConnect::~DefConnect()
{
  delete(channelspecifier_1);
  delete(channelspecifier_2);

}

void DefConnect::accept(Visitor *v)
{
  v->visitDefConnect(this);
}

DefConnect *DefConnect::clone() const
{
  return new DefConnect(*this);
}



/********************   DefFor    ********************/
DefFor::DefFor(Id p1, Exp *p2, Exp *p3, ListModDef *p4)
{
  id_ = p1;
  exp_1 = p2;
  exp_2 = p3;
  listmoddef_ = p4;

}

DefFor::DefFor(const DefFor & other)
{
  id_ = other.id_;
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  listmoddef_ = other.listmoddef_->clone();

}

DefFor &DefFor::operator=(const DefFor & other)
{
  DefFor tmp(other);
  swap(tmp);
  return *this;
}

void DefFor::swap(DefFor & other)
{
  std::swap(id_, other.id_);
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(listmoddef_, other.listmoddef_);

}

DefFor::~DefFor()
{
  delete(exp_1);
  delete(exp_2);
  delete(listmoddef_);

}

void DefFor::accept(Visitor *v)
{
  v->visitDefFor(this);
}

DefFor *DefFor::clone() const
{
  return new DefFor(*this);
}



/********************   DefIf    ********************/
DefIf::DefIf(Exp *p1, ListModDef *p2)
{
  exp_ = p1;
  listmoddef_ = p2;

}

DefIf::DefIf(const DefIf & other)
{
  exp_ = other.exp_->clone();
  listmoddef_ = other.listmoddef_->clone();

}

DefIf &DefIf::operator=(const DefIf & other)
{
  DefIf tmp(other);
  swap(tmp);
  return *this;
}

void DefIf::swap(DefIf & other)
{
  std::swap(exp_, other.exp_);
  std::swap(listmoddef_, other.listmoddef_);

}

DefIf::~DefIf()
{
  delete(exp_);
  delete(listmoddef_);

}

void DefIf::accept(Visitor *v)
{
  v->visitDefIf(this);
}

DefIf *DefIf::clone() const
{
  return new DefIf(*this);
}



/********************   SimpleCS    ********************/
SimpleCS::SimpleCS(Id p1)
{
  id_ = p1;

}

SimpleCS::SimpleCS(const SimpleCS & other)
{
  id_ = other.id_;

}

SimpleCS &SimpleCS::operator=(const SimpleCS & other)
{
  SimpleCS tmp(other);
  swap(tmp);
  return *this;
}

void SimpleCS::swap(SimpleCS & other)
{
  std::swap(id_, other.id_);

}

SimpleCS::~SimpleCS()
{

}

void SimpleCS::accept(Visitor *v)
{
  v->visitSimpleCS(this);
}

SimpleCS *SimpleCS::clone() const
{
  return new SimpleCS(*this);
}



/********************   DotCS    ********************/
DotCS::DotCS(Id p1, Id p2)
{
  id_1 = p1;
  id_2 = p2;

}

DotCS::DotCS(const DotCS & other)
{
  id_1 = other.id_1;
  id_2 = other.id_2;

}

DotCS &DotCS::operator=(const DotCS & other)
{
  DotCS tmp(other);
  swap(tmp);
  return *this;
}

void DotCS::swap(DotCS & other)
{
  std::swap(id_1, other.id_1);
  std::swap(id_2, other.id_2);

}

DotCS::~DotCS()
{

}

void DotCS::accept(Visitor *v)
{
  v->visitDotCS(this);
}

DotCS *DotCS::clone() const
{
  return new DotCS(*this);
}



/********************   ArrayDotCS    ********************/
ArrayDotCS::ArrayDotCS(Id p1, Exp *p2, Id p3)
{
  id_1 = p1;
  exp_ = p2;
  id_2 = p3;

}

ArrayDotCS::ArrayDotCS(const ArrayDotCS & other)
{
  id_1 = other.id_1;
  exp_ = other.exp_->clone();
  id_2 = other.id_2;

}

ArrayDotCS &ArrayDotCS::operator=(const ArrayDotCS & other)
{
  ArrayDotCS tmp(other);
  swap(tmp);
  return *this;
}

void ArrayDotCS::swap(ArrayDotCS & other)
{
  std::swap(id_1, other.id_1);
  std::swap(exp_, other.exp_);
  std::swap(id_2, other.id_2);

}

ArrayDotCS::~ArrayDotCS()
{
  delete(exp_);

}

void ArrayDotCS::accept(Visitor *v)
{
  v->visitArrayDotCS(this);
}

ArrayDotCS *ArrayDotCS::clone() const
{
  return new ArrayDotCS(*this);
}



/********************   NoEvName    ********************/
NoEvName::NoEvName()
{

}

NoEvName::NoEvName(const NoEvName & other)
{

}

NoEvName &NoEvName::operator=(const NoEvName & other)
{
  NoEvName tmp(other);
  swap(tmp);
  return *this;
}

void NoEvName::swap(NoEvName & other)
{

}

NoEvName::~NoEvName()
{

}

void NoEvName::accept(Visitor *v)
{
  v->visitNoEvName(this);
}

NoEvName *NoEvName::clone() const
{
  return new NoEvName(*this);
}



/********************   EvName    ********************/
EvName::EvName(Id p1)
{
  id_ = p1;

}

EvName::EvName(const EvName & other)
{
  id_ = other.id_;

}

EvName &EvName::operator=(const EvName & other)
{
  EvName tmp(other);
  swap(tmp);
  return *this;
}

void EvName::swap(EvName & other)
{
  std::swap(id_, other.id_);

}

EvName::~EvName()
{

}

void EvName::accept(Visitor *v)
{
  v->visitEvName(this);
}

EvName *EvName::clone() const
{
  return new EvName(*this);
}



/********************   EventParamWithName    ********************/
EventParamWithName::EventParamWithName(EventOrCond *p1, Id p2)
{
  eventorcond_ = p1;
  id_ = p2;

}

EventParamWithName::EventParamWithName(const EventParamWithName & other)
{
  eventorcond_ = other.eventorcond_->clone();
  id_ = other.id_;

}

EventParamWithName &EventParamWithName::operator=(const EventParamWithName & other)
{
  EventParamWithName tmp(other);
  swap(tmp);
  return *this;
}

void EventParamWithName::swap(EventParamWithName & other)
{
  std::swap(eventorcond_, other.eventorcond_);
  std::swap(id_, other.id_);

}

EventParamWithName::~EventParamWithName()
{
  delete(eventorcond_);

}

void EventParamWithName::accept(Visitor *v)
{
  v->visitEventParamWithName(this);
}

EventParamWithName *EventParamWithName::clone() const
{
  return new EventParamWithName(*this);
}



/********************   EventParamNoName    ********************/
EventParamNoName::EventParamNoName(EventOrCond *p1)
{
  eventorcond_ = p1;

}

EventParamNoName::EventParamNoName(const EventParamNoName & other)
{
  eventorcond_ = other.eventorcond_->clone();

}

EventParamNoName &EventParamNoName::operator=(const EventParamNoName & other)
{
  EventParamNoName tmp(other);
  swap(tmp);
  return *this;
}

void EventParamNoName::swap(EventParamNoName & other)
{
  std::swap(eventorcond_, other.eventorcond_);

}

EventParamNoName::~EventParamNoName()
{
  delete(eventorcond_);

}

void EventParamNoName::accept(Visitor *v)
{
  v->visitEventParamNoName(this);
}

EventParamNoName *EventParamNoName::clone() const
{
  return new EventParamNoName(*this);
}



/********************   CSEventCond    ********************/
CSEventCond::CSEventCond(ChannelSpecifier *p1)
{
  channelspecifier_ = p1;

}

CSEventCond::CSEventCond(const CSEventCond & other)
{
  channelspecifier_ = other.channelspecifier_->clone();

}

CSEventCond &CSEventCond::operator=(const CSEventCond & other)
{
  CSEventCond tmp(other);
  swap(tmp);
  return *this;
}

void CSEventCond::swap(CSEventCond & other)
{
  std::swap(channelspecifier_, other.channelspecifier_);

}

CSEventCond::~CSEventCond()
{
  delete(channelspecifier_);

}

void CSEventCond::accept(Visitor *v)
{
  v->visitCSEventCond(this);
}

CSEventCond *CSEventCond::clone() const
{
  return new CSEventCond(*this);
}



/********************   ListEvOr    ********************/
ListEvOr::ListEvOr(ListEventOrList *p1)
{
  listeventorlist_ = p1;

}

ListEvOr::ListEvOr(const ListEvOr & other)
{
  listeventorlist_ = other.listeventorlist_->clone();

}

ListEvOr &ListEvOr::operator=(const ListEvOr & other)
{
  ListEvOr tmp(other);
  swap(tmp);
  return *this;
}

void ListEvOr::swap(ListEvOr & other)
{
  std::swap(listeventorlist_, other.listeventorlist_);

}

ListEvOr::~ListEvOr()
{
  delete(listeventorlist_);

}

void ListEvOr::accept(Visitor *v)
{
  v->visitListEvOr(this);
}

ListEvOr *ListEvOr::clone() const
{
  return new ListEvOr(*this);
}



/********************   EventOrListChannelSpecifier    ********************/
EventOrListChannelSpecifier::EventOrListChannelSpecifier(ChannelSpecifier *p1)
{
  channelspecifier_ = p1;

}

EventOrListChannelSpecifier::EventOrListChannelSpecifier(const EventOrListChannelSpecifier & other)
{
  channelspecifier_ = other.channelspecifier_->clone();

}

EventOrListChannelSpecifier &EventOrListChannelSpecifier::operator=(const EventOrListChannelSpecifier & other)
{
  EventOrListChannelSpecifier tmp(other);
  swap(tmp);
  return *this;
}

void EventOrListChannelSpecifier::swap(EventOrListChannelSpecifier & other)
{
  std::swap(channelspecifier_, other.channelspecifier_);

}

EventOrListChannelSpecifier::~EventOrListChannelSpecifier()
{
  delete(channelspecifier_);

}

void EventOrListChannelSpecifier::accept(Visitor *v)
{
  v->visitEventOrListChannelSpecifier(this);
}

EventOrListChannelSpecifier *EventOrListChannelSpecifier::clone() const
{
  return new EventOrListChannelSpecifier(*this);
}



/********************   DefSubstor    ********************/
DefSubstor::DefSubstor(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

DefSubstor::DefSubstor(const DefSubstor & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

DefSubstor &DefSubstor::operator=(const DefSubstor & other)
{
  DefSubstor tmp(other);
  swap(tmp);
  return *this;
}

void DefSubstor::swap(DefSubstor & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

DefSubstor::~DefSubstor()
{
  delete(type_);

}

void DefSubstor::accept(Visitor *v)
{
  v->visitDefSubstor(this);
}

DefSubstor *DefSubstor::clone() const
{
  return new DefSubstor(*this);
}



/********************   DefFunction    ********************/
DefFunction::DefFunction(Type *p1, Id p2, ListFuncParam *p3, ListStatement *p4)
{
  type_ = p1;
  id_ = p2;
  listfuncparam_ = p3;
  liststatement_ = p4;

}

DefFunction::DefFunction(const DefFunction & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;
  listfuncparam_ = other.listfuncparam_->clone();
  liststatement_ = other.liststatement_->clone();

}

DefFunction &DefFunction::operator=(const DefFunction & other)
{
  DefFunction tmp(other);
  swap(tmp);
  return *this;
}

void DefFunction::swap(DefFunction & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);
  std::swap(listfuncparam_, other.listfuncparam_);
  std::swap(liststatement_, other.liststatement_);

}

DefFunction::~DefFunction()
{
  delete(type_);
  delete(listfuncparam_);
  delete(liststatement_);

}

void DefFunction::accept(Visitor *v)
{
  v->visitDefFunction(this);
}

DefFunction *DefFunction::clone() const
{
  return new DefFunction(*this);
}



/********************   FuncParam1    ********************/
FuncParam1::FuncParam1(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

FuncParam1::FuncParam1(const FuncParam1 & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

FuncParam1 &FuncParam1::operator=(const FuncParam1 & other)
{
  FuncParam1 tmp(other);
  swap(tmp);
  return *this;
}

void FuncParam1::swap(FuncParam1 & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

FuncParam1::~FuncParam1()
{
  delete(type_);

}

void FuncParam1::accept(Visitor *v)
{
  v->visitFuncParam1(this);
}

FuncParam1 *FuncParam1::clone() const
{
  return new FuncParam1(*this);
}



/********************   NoType    ********************/
NoType::NoType()
{

}

NoType::NoType(const NoType & other)
{

}

NoType &NoType::operator=(const NoType & other)
{
  NoType tmp(other);
  swap(tmp);
  return *this;
}

void NoType::swap(NoType & other)
{

}

NoType::~NoType()
{

}

void NoType::accept(Visitor *v)
{
  v->visitNoType(this);
}

NoType *NoType::clone() const
{
  return new NoType(*this);
}



/********************   TypeSpec    ********************/
TypeSpec::TypeSpec(Type *p1)
{
  type_ = p1;

}

TypeSpec::TypeSpec(const TypeSpec & other)
{
  type_ = other.type_->clone();

}

TypeSpec &TypeSpec::operator=(const TypeSpec & other)
{
  TypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpec::swap(TypeSpec & other)
{
  std::swap(type_, other.type_);

}

TypeSpec::~TypeSpec()
{
  delete(type_);

}

void TypeSpec::accept(Visitor *v)
{
  v->visitTypeSpec(this);
}

TypeSpec *TypeSpec::clone() const
{
  return new TypeSpec(*this);
}



/********************   VarStmt    ********************/
VarStmt::VarStmt(OptionalType *p1, Id p2, VarAssignment *p3)
{
  optionaltype_ = p1;
  id_ = p2;
  varassignment_ = p3;

}

VarStmt::VarStmt(const VarStmt & other)
{
  optionaltype_ = other.optionaltype_->clone();
  id_ = other.id_;
  varassignment_ = other.varassignment_->clone();

}

VarStmt &VarStmt::operator=(const VarStmt & other)
{
  VarStmt tmp(other);
  swap(tmp);
  return *this;
}

void VarStmt::swap(VarStmt & other)
{
  std::swap(optionaltype_, other.optionaltype_);
  std::swap(id_, other.id_);
  std::swap(varassignment_, other.varassignment_);

}

VarStmt::~VarStmt()
{
  delete(optionaltype_);
  delete(varassignment_);

}

void VarStmt::accept(Visitor *v)
{
  v->visitVarStmt(this);
}

VarStmt *VarStmt::clone() const
{
  return new VarStmt(*this);
}



/********************   AssignStmt    ********************/
AssignStmt::AssignStmt(Id p1, Exp *p2)
{
  id_ = p1;
  exp_ = p2;

}

AssignStmt::AssignStmt(const AssignStmt & other)
{
  id_ = other.id_;
  exp_ = other.exp_->clone();

}

AssignStmt &AssignStmt::operator=(const AssignStmt & other)
{
  AssignStmt tmp(other);
  swap(tmp);
  return *this;
}

void AssignStmt::swap(AssignStmt & other)
{
  std::swap(id_, other.id_);
  std::swap(exp_, other.exp_);

}

AssignStmt::~AssignStmt()
{
  delete(exp_);

}

void AssignStmt::accept(Visitor *v)
{
  v->visitAssignStmt(this);
}

AssignStmt *AssignStmt::clone() const
{
  return new AssignStmt(*this);
}



/********************   AssignArrStmt    ********************/
AssignArrStmt::AssignArrStmt(Id p1, Exp *p2, Exp *p3)
{
  id_ = p1;
  exp_1 = p2;
  exp_2 = p3;

}

AssignArrStmt::AssignArrStmt(const AssignArrStmt & other)
{
  id_ = other.id_;
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

AssignArrStmt &AssignArrStmt::operator=(const AssignArrStmt & other)
{
  AssignArrStmt tmp(other);
  swap(tmp);
  return *this;
}

void AssignArrStmt::swap(AssignArrStmt & other)
{
  std::swap(id_, other.id_);
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

AssignArrStmt::~AssignArrStmt()
{
  delete(exp_1);
  delete(exp_2);

}

void AssignArrStmt::accept(Visitor *v)
{
  v->visitAssignArrStmt(this);
}

AssignArrStmt *AssignArrStmt::clone() const
{
  return new AssignArrStmt(*this);
}



/********************   IfStmt    ********************/
IfStmt::IfStmt(Exp *p1, Block *p2, ElseBlock *p3)
{
  exp_ = p1;
  block_ = p2;
  elseblock_ = p3;

}

IfStmt::IfStmt(const IfStmt & other)
{
  exp_ = other.exp_->clone();
  block_ = other.block_->clone();
  elseblock_ = other.elseblock_->clone();

}

IfStmt &IfStmt::operator=(const IfStmt & other)
{
  IfStmt tmp(other);
  swap(tmp);
  return *this;
}

void IfStmt::swap(IfStmt & other)
{
  std::swap(exp_, other.exp_);
  std::swap(block_, other.block_);
  std::swap(elseblock_, other.elseblock_);

}

IfStmt::~IfStmt()
{
  delete(exp_);
  delete(block_);
  delete(elseblock_);

}

void IfStmt::accept(Visitor *v)
{
  v->visitIfStmt(this);
}

IfStmt *IfStmt::clone() const
{
  return new IfStmt(*this);
}



/********************   BlockStmt    ********************/
BlockStmt::BlockStmt(Block *p1)
{
  block_ = p1;

}

BlockStmt::BlockStmt(const BlockStmt & other)
{
  block_ = other.block_->clone();

}

BlockStmt &BlockStmt::operator=(const BlockStmt & other)
{
  BlockStmt tmp(other);
  swap(tmp);
  return *this;
}

void BlockStmt::swap(BlockStmt & other)
{
  std::swap(block_, other.block_);

}

BlockStmt::~BlockStmt()
{
  delete(block_);

}

void BlockStmt::accept(Visitor *v)
{
  v->visitBlockStmt(this);
}

BlockStmt *BlockStmt::clone() const
{
  return new BlockStmt(*this);
}



/********************   PushStmt    ********************/
PushStmt::PushStmt(Id p1, PushSubDest *p2, Exp *p3)
{
  id_ = p1;
  pushsubdest_ = p2;
  exp_ = p3;

}

PushStmt::PushStmt(const PushStmt & other)
{
  id_ = other.id_;
  pushsubdest_ = other.pushsubdest_->clone();
  exp_ = other.exp_->clone();

}

PushStmt &PushStmt::operator=(const PushStmt & other)
{
  PushStmt tmp(other);
  swap(tmp);
  return *this;
}

void PushStmt::swap(PushStmt & other)
{
  std::swap(id_, other.id_);
  std::swap(pushsubdest_, other.pushsubdest_);
  std::swap(exp_, other.exp_);

}

PushStmt::~PushStmt()
{
  delete(pushsubdest_);
  delete(exp_);

}

void PushStmt::accept(Visitor *v)
{
  v->visitPushStmt(this);
}

PushStmt *PushStmt::clone() const
{
  return new PushStmt(*this);
}



/********************   StaticForStmt    ********************/
StaticForStmt::StaticForStmt(Id p1, Exp *p2, Exp *p3, Block *p4)
{
  id_ = p1;
  exp_1 = p2;
  exp_2 = p3;
  block_ = p4;

}

StaticForStmt::StaticForStmt(const StaticForStmt & other)
{
  id_ = other.id_;
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  block_ = other.block_->clone();

}

StaticForStmt &StaticForStmt::operator=(const StaticForStmt & other)
{
  StaticForStmt tmp(other);
  swap(tmp);
  return *this;
}

void StaticForStmt::swap(StaticForStmt & other)
{
  std::swap(id_, other.id_);
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(block_, other.block_);

}

StaticForStmt::~StaticForStmt()
{
  delete(exp_1);
  delete(exp_2);
  delete(block_);

}

void StaticForStmt::accept(Visitor *v)
{
  v->visitStaticForStmt(this);
}

StaticForStmt *StaticForStmt::clone() const
{
  return new StaticForStmt(*this);
}



/********************   StaticIfStmt    ********************/
StaticIfStmt::StaticIfStmt(Exp *p1, Block *p2)
{
  exp_ = p1;
  block_ = p2;

}

StaticIfStmt::StaticIfStmt(const StaticIfStmt & other)
{
  exp_ = other.exp_->clone();
  block_ = other.block_->clone();

}

StaticIfStmt &StaticIfStmt::operator=(const StaticIfStmt & other)
{
  StaticIfStmt tmp(other);
  swap(tmp);
  return *this;
}

void StaticIfStmt::swap(StaticIfStmt & other)
{
  std::swap(exp_, other.exp_);
  std::swap(block_, other.block_);

}

StaticIfStmt::~StaticIfStmt()
{
  delete(exp_);
  delete(block_);

}

void StaticIfStmt::accept(Visitor *v)
{
  v->visitStaticIfStmt(this);
}

StaticIfStmt *StaticIfStmt::clone() const
{
  return new StaticIfStmt(*this);
}



/********************   ReturnStmt    ********************/
ReturnStmt::ReturnStmt(Exp *p1)
{
  exp_ = p1;

}

ReturnStmt::ReturnStmt(const ReturnStmt & other)
{
  exp_ = other.exp_->clone();

}

ReturnStmt &ReturnStmt::operator=(const ReturnStmt & other)
{
  ReturnStmt tmp(other);
  swap(tmp);
  return *this;
}

void ReturnStmt::swap(ReturnStmt & other)
{
  std::swap(exp_, other.exp_);

}

ReturnStmt::~ReturnStmt()
{
  delete(exp_);

}

void ReturnStmt::accept(Visitor *v)
{
  v->visitReturnStmt(this);
}

ReturnStmt *ReturnStmt::clone() const
{
  return new ReturnStmt(*this);
}



/********************   WaitUntilStmt    ********************/
WaitUntilStmt::WaitUntilStmt(Exp *p1)
{
  exp_ = p1;

}

WaitUntilStmt::WaitUntilStmt(const WaitUntilStmt & other)
{
  exp_ = other.exp_->clone();

}

WaitUntilStmt &WaitUntilStmt::operator=(const WaitUntilStmt & other)
{
  WaitUntilStmt tmp(other);
  swap(tmp);
  return *this;
}

void WaitUntilStmt::swap(WaitUntilStmt & other)
{
  std::swap(exp_, other.exp_);

}

WaitUntilStmt::~WaitUntilStmt()
{
  delete(exp_);

}

void WaitUntilStmt::accept(Visitor *v)
{
  v->visitWaitUntilStmt(this);
}

WaitUntilStmt *WaitUntilStmt::clone() const
{
  return new WaitUntilStmt(*this);
}



/********************   PushSubreg    ********************/
PushSubreg::PushSubreg(Id p1)
{
  id_ = p1;

}

PushSubreg::PushSubreg(const PushSubreg & other)
{
  id_ = other.id_;

}

PushSubreg &PushSubreg::operator=(const PushSubreg & other)
{
  PushSubreg tmp(other);
  swap(tmp);
  return *this;
}

void PushSubreg::swap(PushSubreg & other)
{
  std::swap(id_, other.id_);

}

PushSubreg::~PushSubreg()
{

}

void PushSubreg::accept(Visitor *v)
{
  v->visitPushSubreg(this);
}

PushSubreg *PushSubreg::clone() const
{
  return new PushSubreg(*this);
}



/********************   PushArray    ********************/
PushArray::PushArray(Exp *p1)
{
  exp_ = p1;

}

PushArray::PushArray(const PushArray & other)
{
  exp_ = other.exp_->clone();

}

PushArray &PushArray::operator=(const PushArray & other)
{
  PushArray tmp(other);
  swap(tmp);
  return *this;
}

void PushArray::swap(PushArray & other)
{
  std::swap(exp_, other.exp_);

}

PushArray::~PushArray()
{
  delete(exp_);

}

void PushArray::accept(Visitor *v)
{
  v->visitPushArray(this);
}

PushArray *PushArray::clone() const
{
  return new PushArray(*this);
}



/********************   PushArrayDot    ********************/
PushArrayDot::PushArrayDot(Exp *p1, Id p2)
{
  exp_ = p1;
  id_ = p2;

}

PushArrayDot::PushArrayDot(const PushArrayDot & other)
{
  exp_ = other.exp_->clone();
  id_ = other.id_;

}

PushArrayDot &PushArrayDot::operator=(const PushArrayDot & other)
{
  PushArrayDot tmp(other);
  swap(tmp);
  return *this;
}

void PushArrayDot::swap(PushArrayDot & other)
{
  std::swap(exp_, other.exp_);
  std::swap(id_, other.id_);

}

PushArrayDot::~PushArrayDot()
{
  delete(exp_);

}

void PushArrayDot::accept(Visitor *v)
{
  v->visitPushArrayDot(this);
}

PushArrayDot *PushArrayDot::clone() const
{
  return new PushArrayDot(*this);
}



/********************   PushReg    ********************/
PushReg::PushReg()
{

}

PushReg::PushReg(const PushReg & other)
{

}

PushReg &PushReg::operator=(const PushReg & other)
{
  PushReg tmp(other);
  swap(tmp);
  return *this;
}

void PushReg::swap(PushReg & other)
{

}

PushReg::~PushReg()
{

}

void PushReg::accept(Visitor *v)
{
  v->visitPushReg(this);
}

PushReg *PushReg::clone() const
{
  return new PushReg(*this);
}



/********************   VarAssign    ********************/
VarAssign::VarAssign(Exp *p1)
{
  exp_ = p1;

}

VarAssign::VarAssign(const VarAssign & other)
{
  exp_ = other.exp_->clone();

}

VarAssign &VarAssign::operator=(const VarAssign & other)
{
  VarAssign tmp(other);
  swap(tmp);
  return *this;
}

void VarAssign::swap(VarAssign & other)
{
  std::swap(exp_, other.exp_);

}

VarAssign::~VarAssign()
{
  delete(exp_);

}

void VarAssign::accept(Visitor *v)
{
  v->visitVarAssign(this);
}

VarAssign *VarAssign::clone() const
{
  return new VarAssign(*this);
}



/********************   NoVarAssign    ********************/
NoVarAssign::NoVarAssign()
{

}

NoVarAssign::NoVarAssign(const NoVarAssign & other)
{

}

NoVarAssign &NoVarAssign::operator=(const NoVarAssign & other)
{
  NoVarAssign tmp(other);
  swap(tmp);
  return *this;
}

void NoVarAssign::swap(NoVarAssign & other)
{

}

NoVarAssign::~NoVarAssign()
{

}

void NoVarAssign::accept(Visitor *v)
{
  v->visitNoVarAssign(this);
}

NoVarAssign *NoVarAssign::clone() const
{
  return new NoVarAssign(*this);
}



/********************   Block1    ********************/
Block1::Block1(ListBlockAttr *p1, ListStatement *p2)
{
  listblockattr_ = p1;
  liststatement_ = p2;

}

Block1::Block1(const Block1 & other)
{
  listblockattr_ = other.listblockattr_->clone();
  liststatement_ = other.liststatement_->clone();

}

Block1 &Block1::operator=(const Block1 & other)
{
  Block1 tmp(other);
  swap(tmp);
  return *this;
}

void Block1::swap(Block1 & other)
{
  std::swap(listblockattr_, other.listblockattr_);
  std::swap(liststatement_, other.liststatement_);

}

Block1::~Block1()
{
  delete(listblockattr_);
  delete(liststatement_);

}

void Block1::accept(Visitor *v)
{
  v->visitBlock1(this);
}

Block1 *Block1::clone() const
{
  return new Block1(*this);
}



/********************   BlockAttr_atomic    ********************/
BlockAttr_atomic::BlockAttr_atomic()
{

}

BlockAttr_atomic::BlockAttr_atomic(const BlockAttr_atomic & other)
{

}

BlockAttr_atomic &BlockAttr_atomic::operator=(const BlockAttr_atomic & other)
{
  BlockAttr_atomic tmp(other);
  swap(tmp);
  return *this;
}

void BlockAttr_atomic::swap(BlockAttr_atomic & other)
{

}

BlockAttr_atomic::~BlockAttr_atomic()
{

}

void BlockAttr_atomic::accept(Visitor *v)
{
  v->visitBlockAttr_atomic(this);
}

BlockAttr_atomic *BlockAttr_atomic::clone() const
{
  return new BlockAttr_atomic(*this);
}



/********************   BlockAttr_xact    ********************/
BlockAttr_xact::BlockAttr_xact()
{

}

BlockAttr_xact::BlockAttr_xact(const BlockAttr_xact & other)
{

}

BlockAttr_xact &BlockAttr_xact::operator=(const BlockAttr_xact & other)
{
  BlockAttr_xact tmp(other);
  swap(tmp);
  return *this;
}

void BlockAttr_xact::swap(BlockAttr_xact & other)
{

}

BlockAttr_xact::~BlockAttr_xact()
{

}

void BlockAttr_xact::accept(Visitor *v)
{
  v->visitBlockAttr_xact(this);
}

BlockAttr_xact *BlockAttr_xact::clone() const
{
  return new BlockAttr_xact(*this);
}



/********************   ElseIf    ********************/
ElseIf::ElseIf(Exp *p1, Block *p2, ElseBlock *p3)
{
  exp_ = p1;
  block_ = p2;
  elseblock_ = p3;

}

ElseIf::ElseIf(const ElseIf & other)
{
  exp_ = other.exp_->clone();
  block_ = other.block_->clone();
  elseblock_ = other.elseblock_->clone();

}

ElseIf &ElseIf::operator=(const ElseIf & other)
{
  ElseIf tmp(other);
  swap(tmp);
  return *this;
}

void ElseIf::swap(ElseIf & other)
{
  std::swap(exp_, other.exp_);
  std::swap(block_, other.block_);
  std::swap(elseblock_, other.elseblock_);

}

ElseIf::~ElseIf()
{
  delete(exp_);
  delete(block_);
  delete(elseblock_);

}

void ElseIf::accept(Visitor *v)
{
  v->visitElseIf(this);
}

ElseIf *ElseIf::clone() const
{
  return new ElseIf(*this);
}



/********************   Else    ********************/
Else::Else(Block *p1)
{
  block_ = p1;

}

Else::Else(const Else & other)
{
  block_ = other.block_->clone();

}

Else &Else::operator=(const Else & other)
{
  Else tmp(other);
  swap(tmp);
  return *this;
}

void Else::swap(Else & other)
{
  std::swap(block_, other.block_);

}

Else::~Else()
{
  delete(block_);

}

void Else::accept(Visitor *v)
{
  v->visitElse(this);
}

Else *Else::clone() const
{
  return new Else(*this);
}



/********************   NoElse    ********************/
NoElse::NoElse()
{

}

NoElse::NoElse(const NoElse & other)
{

}

NoElse &NoElse::operator=(const NoElse & other)
{
  NoElse tmp(other);
  swap(tmp);
  return *this;
}

void NoElse::swap(NoElse & other)
{

}

NoElse::~NoElse()
{

}

void NoElse::accept(Visitor *v)
{
  v->visitNoElse(this);
}

NoElse *NoElse::clone() const
{
  return new NoElse(*this);
}



/********************   EVoid    ********************/
EVoid::EVoid()
{

}

EVoid::EVoid(const EVoid & other)
{

}

EVoid &EVoid::operator=(const EVoid & other)
{
  EVoid tmp(other);
  swap(tmp);
  return *this;
}

void EVoid::swap(EVoid & other)
{

}

EVoid::~EVoid()
{

}

void EVoid::accept(Visitor *v)
{
  v->visitEVoid(this);
}

EVoid *EVoid::clone() const
{
  return new EVoid(*this);
}



/********************   ETrue    ********************/
ETrue::ETrue()
{

}

ETrue::ETrue(const ETrue & other)
{

}

ETrue &ETrue::operator=(const ETrue & other)
{
  ETrue tmp(other);
  swap(tmp);
  return *this;
}

void ETrue::swap(ETrue & other)
{

}

ETrue::~ETrue()
{

}

void ETrue::accept(Visitor *v)
{
  v->visitETrue(this);
}

ETrue *ETrue::clone() const
{
  return new ETrue(*this);
}



/********************   EFalse    ********************/
EFalse::EFalse()
{

}

EFalse::EFalse(const EFalse & other)
{

}

EFalse &EFalse::operator=(const EFalse & other)
{
  EFalse tmp(other);
  swap(tmp);
  return *this;
}

void EFalse::swap(EFalse & other)
{

}

EFalse::~EFalse()
{

}

void EFalse::accept(Visitor *v)
{
  v->visitEFalse(this);
}

EFalse *EFalse::clone() const
{
  return new EFalse(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EDouble    ********************/
EDouble::EDouble(Double p1)
{
  double_ = p1;

}

EDouble::EDouble(const EDouble & other)
{
  double_ = other.double_;

}

EDouble &EDouble::operator=(const EDouble & other)
{
  EDouble tmp(other);
  swap(tmp);
  return *this;
}

void EDouble::swap(EDouble & other)
{
  std::swap(double_, other.double_);

}

EDouble::~EDouble()
{

}

void EDouble::accept(Visitor *v)
{
  v->visitEDouble(this);
}

EDouble *EDouble::clone() const
{
  return new EDouble(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   EStructLiteral    ********************/
EStructLiteral::EStructLiteral(Type *p1, ListStructLiteralField *p2)
{
  type_ = p1;
  liststructliteralfield_ = p2;

}

EStructLiteral::EStructLiteral(const EStructLiteral & other)
{
  type_ = other.type_->clone();
  liststructliteralfield_ = other.liststructliteralfield_->clone();

}

EStructLiteral &EStructLiteral::operator=(const EStructLiteral & other)
{
  EStructLiteral tmp(other);
  swap(tmp);
  return *this;
}

void EStructLiteral::swap(EStructLiteral & other)
{
  std::swap(type_, other.type_);
  std::swap(liststructliteralfield_, other.liststructliteralfield_);

}

EStructLiteral::~EStructLiteral()
{
  delete(type_);
  delete(liststructliteralfield_);

}

void EStructLiteral::accept(Visitor *v)
{
  v->visitEStructLiteral(this);
}

EStructLiteral *EStructLiteral::clone() const
{
  return new EStructLiteral(*this);
}



/********************   EVectorLiteral    ********************/
EVectorLiteral::EVectorLiteral(ListExp *p1)
{
  listexp_ = p1;

}

EVectorLiteral::EVectorLiteral(const EVectorLiteral & other)
{
  listexp_ = other.listexp_->clone();

}

EVectorLiteral &EVectorLiteral::operator=(const EVectorLiteral & other)
{
  EVectorLiteral tmp(other);
  swap(tmp);
  return *this;
}

void EVectorLiteral::swap(EVectorLiteral & other)
{
  std::swap(listexp_, other.listexp_);

}

EVectorLiteral::~EVectorLiteral()
{
  delete(listexp_);

}

void EVectorLiteral::accept(Visitor *v)
{
  v->visitEVectorLiteral(this);
}

EVectorLiteral *EVectorLiteral::clone() const
{
  return new EVectorLiteral(*this);
}



/********************   EId    ********************/
EId::EId(Id p1)
{
  id_ = p1;

}

EId::EId(const EId & other)
{
  id_ = other.id_;

}

EId &EId::operator=(const EId & other)
{
  EId tmp(other);
  swap(tmp);
  return *this;
}

void EId::swap(EId & other)
{
  std::swap(id_, other.id_);

}

EId::~EId()
{

}

void EId::accept(Visitor *v)
{
  v->visitEId(this);
}

EId *EId::clone() const
{
  return new EId(*this);
}



/********************   EArrAcc    ********************/
EArrAcc::EArrAcc(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EArrAcc::EArrAcc(const EArrAcc & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EArrAcc &EArrAcc::operator=(const EArrAcc & other)
{
  EArrAcc tmp(other);
  swap(tmp);
  return *this;
}

void EArrAcc::swap(EArrAcc & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EArrAcc::~EArrAcc()
{
  delete(exp_1);
  delete(exp_2);

}

void EArrAcc::accept(Visitor *v)
{
  v->visitEArrAcc(this);
}

EArrAcc *EArrAcc::clone() const
{
  return new EArrAcc(*this);
}



/********************   ESlice    ********************/
ESlice::ESlice(Exp *p1, Exp *p2, Exp *p3)
{
  exp_1 = p1;
  exp_2 = p2;
  exp_3 = p3;

}

ESlice::ESlice(const ESlice & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  exp_3 = other.exp_3->clone();

}

ESlice &ESlice::operator=(const ESlice & other)
{
  ESlice tmp(other);
  swap(tmp);
  return *this;
}

void ESlice::swap(ESlice & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(exp_3, other.exp_3);

}

ESlice::~ESlice()
{
  delete(exp_1);
  delete(exp_2);
  delete(exp_3);

}

void ESlice::accept(Visitor *v)
{
  v->visitESlice(this);
}

ESlice *ESlice::clone() const
{
  return new ESlice(*this);
}



/********************   EDot    ********************/
EDot::EDot(Exp *p1, Id p2)
{
  exp_ = p1;
  id_ = p2;

}

EDot::EDot(const EDot & other)
{
  exp_ = other.exp_->clone();
  id_ = other.id_;

}

EDot &EDot::operator=(const EDot & other)
{
  EDot tmp(other);
  swap(tmp);
  return *this;
}

void EDot::swap(EDot & other)
{
  std::swap(exp_, other.exp_);
  std::swap(id_, other.id_);

}

EDot::~EDot()
{
  delete(exp_);

}

void EDot::accept(Visitor *v)
{
  v->visitEDot(this);
}

EDot *EDot::clone() const
{
  return new EDot(*this);
}



/********************   ETimes    ********************/
ETimes::ETimes(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ETimes::ETimes(const ETimes & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ETimes &ETimes::operator=(const ETimes & other)
{
  ETimes tmp(other);
  swap(tmp);
  return *this;
}

void ETimes::swap(ETimes & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ETimes::~ETimes()
{
  delete(exp_1);
  delete(exp_2);

}

void ETimes::accept(Visitor *v)
{
  v->visitETimes(this);
}

ETimes *ETimes::clone() const
{
  return new ETimes(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EPlus    ********************/
EPlus::EPlus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EPlus::EPlus(const EPlus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EPlus &EPlus::operator=(const EPlus & other)
{
  EPlus tmp(other);
  swap(tmp);
  return *this;
}

void EPlus::swap(EPlus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EPlus::~EPlus()
{
  delete(exp_1);
  delete(exp_2);

}

void EPlus::accept(Visitor *v)
{
  v->visitEPlus(this);
}

EPlus *EPlus::clone() const
{
  return new EPlus(*this);
}



/********************   EMinus    ********************/
EMinus::EMinus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMinus::EMinus(const EMinus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMinus &EMinus::operator=(const EMinus & other)
{
  EMinus tmp(other);
  swap(tmp);
  return *this;
}

void EMinus::swap(EMinus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMinus::~EMinus()
{
  delete(exp_1);
  delete(exp_2);

}

void EMinus::accept(Visitor *v)
{
  v->visitEMinus(this);
}

EMinus *EMinus::clone() const
{
  return new EMinus(*this);
}



/********************   ELt    ********************/
ELt::ELt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELt::ELt(const ELt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELt &ELt::operator=(const ELt & other)
{
  ELt tmp(other);
  swap(tmp);
  return *this;
}

void ELt::swap(ELt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELt::~ELt()
{
  delete(exp_1);
  delete(exp_2);

}

void ELt::accept(Visitor *v)
{
  v->visitELt(this);
}

ELt *ELt::clone() const
{
  return new ELt(*this);
}



/********************   EGt    ********************/
EGt::EGt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGt::EGt(const EGt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGt &EGt::operator=(const EGt & other)
{
  EGt tmp(other);
  swap(tmp);
  return *this;
}

void EGt::swap(EGt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGt::~EGt()
{
  delete(exp_1);
  delete(exp_2);

}

void EGt::accept(Visitor *v)
{
  v->visitEGt(this);
}

EGt *EGt::clone() const
{
  return new EGt(*this);
}



/********************   ELtEq    ********************/
ELtEq::ELtEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELtEq::ELtEq(const ELtEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELtEq &ELtEq::operator=(const ELtEq & other)
{
  ELtEq tmp(other);
  swap(tmp);
  return *this;
}

void ELtEq::swap(ELtEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELtEq::~ELtEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ELtEq::accept(Visitor *v)
{
  v->visitELtEq(this);
}

ELtEq *ELtEq::clone() const
{
  return new ELtEq(*this);
}



/********************   EGtEq    ********************/
EGtEq::EGtEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGtEq::EGtEq(const EGtEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGtEq &EGtEq::operator=(const EGtEq & other)
{
  EGtEq tmp(other);
  swap(tmp);
  return *this;
}

void EGtEq::swap(EGtEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGtEq::~EGtEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EGtEq::accept(Visitor *v)
{
  v->visitEGtEq(this);
}

EGtEq *EGtEq::clone() const
{
  return new EGtEq(*this);
}



/********************   EEq    ********************/
EEq::EEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EEq::EEq(const EEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEq::~EEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EEq::accept(Visitor *v)
{
  v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   ENEq    ********************/
ENEq::ENEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENEq::ENEq(const ENEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENEq &ENEq::operator=(const ENEq & other)
{
  ENEq tmp(other);
  swap(tmp);
  return *this;
}

void ENEq::swap(ENEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENEq::~ENEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ENEq::accept(Visitor *v)
{
  v->visitENEq(this);
}

ENEq *ENEq::clone() const
{
  return new ENEq(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAnd::~EAnd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EOr::EOr(const EOr & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EOr::~EOr()
{
  delete(exp_1);
  delete(exp_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   PackageNameId    ********************/
PackageNameId::PackageNameId(Id p1)
{
  id_ = p1;

}

PackageNameId::PackageNameId(const PackageNameId & other)
{
  id_ = other.id_;

}

PackageNameId &PackageNameId::operator=(const PackageNameId & other)
{
  PackageNameId tmp(other);
  swap(tmp);
  return *this;
}

void PackageNameId::swap(PackageNameId & other)
{
  std::swap(id_, other.id_);

}

PackageNameId::~PackageNameId()
{

}

void PackageNameId::accept(Visitor *v)
{
  v->visitPackageNameId(this);
}

PackageNameId *PackageNameId::clone() const
{
  return new PackageNameId(*this);
}



/********************   StructLiteralField1    ********************/
StructLiteralField1::StructLiteralField1(Id p1, Exp *p2)
{
  id_ = p1;
  exp_ = p2;

}

StructLiteralField1::StructLiteralField1(const StructLiteralField1 & other)
{
  id_ = other.id_;
  exp_ = other.exp_->clone();

}

StructLiteralField1 &StructLiteralField1::operator=(const StructLiteralField1 & other)
{
  StructLiteralField1 tmp(other);
  swap(tmp);
  return *this;
}

void StructLiteralField1::swap(StructLiteralField1 & other)
{
  std::swap(id_, other.id_);
  std::swap(exp_, other.exp_);

}

StructLiteralField1::~StructLiteralField1()
{
  delete(exp_);

}

void StructLiteralField1::accept(Visitor *v)
{
  v->visitStructLiteralField1(this);
}

StructLiteralField1 *StructLiteralField1::clone() const
{
  return new StructLiteralField1(*this);
}



/********************   ConstName    ********************/
ConstName::ConstName(Id p1)
{
  id_ = p1;

}

ConstName::ConstName(const ConstName & other)
{
  id_ = other.id_;

}

ConstName &ConstName::operator=(const ConstName & other)
{
  ConstName tmp(other);
  swap(tmp);
  return *this;
}

void ConstName::swap(ConstName & other)
{
  std::swap(id_, other.id_);

}

ConstName::~ConstName()
{

}

void ConstName::accept(Visitor *v)
{
  v->visitConstName(this);
}

ConstName *ConstName::clone() const
{
  return new ConstName(*this);
}



/********************   Int    ********************/
Int::Int(Integer p1)
{
  integer_ = p1;

}

Int::Int(const Int & other)
{
  integer_ = other.integer_;

}

Int &Int::operator=(const Int & other)
{
  Int tmp(other);
  swap(tmp);
  return *this;
}

void Int::swap(Int & other)
{
  std::swap(integer_, other.integer_);

}

Int::~Int()
{

}

void Int::accept(Visitor *v)
{
  v->visitInt(this);
}

Int *Int::clone() const
{
  return new Int(*this);
}



/********************   TyName    ********************/
TyName::TyName(Id p1)
{
  id_ = p1;

}

TyName::TyName(const TyName & other)
{
  id_ = other.id_;

}

TyName &TyName::operator=(const TyName & other)
{
  TyName tmp(other);
  swap(tmp);
  return *this;
}

void TyName::swap(TyName & other)
{
  std::swap(id_, other.id_);

}

TyName::~TyName()
{

}

void TyName::accept(Visitor *v)
{
  v->visitTyName(this);
}

TyName *TyName::clone() const
{
  return new TyName(*this);
}



/********************   TyVoid    ********************/
TyVoid::TyVoid()
{

}

TyVoid::TyVoid(const TyVoid & other)
{

}

TyVoid &TyVoid::operator=(const TyVoid & other)
{
  TyVoid tmp(other);
  swap(tmp);
  return *this;
}

void TyVoid::swap(TyVoid & other)
{

}

TyVoid::~TyVoid()
{

}

void TyVoid::accept(Visitor *v)
{
  v->visitTyVoid(this);
}

TyVoid *TyVoid::clone() const
{
  return new TyVoid(*this);
}



/********************   TyType    ********************/
TyType::TyType()
{

}

TyType::TyType(const TyType & other)
{

}

TyType &TyType::operator=(const TyType & other)
{
  TyType tmp(other);
  swap(tmp);
  return *this;
}

void TyType::swap(TyType & other)
{

}

TyType::~TyType()
{

}

void TyType::accept(Visitor *v)
{
  v->visitTyType(this);
}

TyType *TyType::clone() const
{
  return new TyType(*this);
}



/********************   TyNameParams    ********************/
TyNameParams::TyNameParams(Id p1, ListTemplateArg *p2)
{
  id_ = p1;
  listtemplatearg_ = p2;

}

TyNameParams::TyNameParams(const TyNameParams & other)
{
  id_ = other.id_;
  listtemplatearg_ = other.listtemplatearg_->clone();

}

TyNameParams &TyNameParams::operator=(const TyNameParams & other)
{
  TyNameParams tmp(other);
  swap(tmp);
  return *this;
}

void TyNameParams::swap(TyNameParams & other)
{
  std::swap(id_, other.id_);
  std::swap(listtemplatearg_, other.listtemplatearg_);

}

TyNameParams::~TyNameParams()
{
  delete(listtemplatearg_);

}

void TyNameParams::accept(Visitor *v)
{
  v->visitTyNameParams(this);
}

TyNameParams *TyNameParams::clone() const
{
  return new TyNameParams(*this);
}



/********************   TyArray    ********************/
TyArray::TyArray(Type *p1, IntOrName *p2)
{
  type_ = p1;
  intorname_ = p2;

}

TyArray::TyArray(const TyArray & other)
{
  type_ = other.type_->clone();
  intorname_ = other.intorname_->clone();

}

TyArray &TyArray::operator=(const TyArray & other)
{
  TyArray tmp(other);
  swap(tmp);
  return *this;
}

void TyArray::swap(TyArray & other)
{
  std::swap(type_, other.type_);
  std::swap(intorname_, other.intorname_);

}

TyArray::~TyArray()
{
  delete(type_);
  delete(intorname_);

}

void TyArray::accept(Visitor *v)
{
  v->visitTyArray(this);
}

TyArray *TyArray::clone() const
{
  return new TyArray(*this);
}



/********************   TyVector    ********************/
TyVector::TyVector(Type *p1, IntOrName *p2)
{
  type_ = p1;
  intorname_ = p2;

}

TyVector::TyVector(const TyVector & other)
{
  type_ = other.type_->clone();
  intorname_ = other.intorname_->clone();

}

TyVector &TyVector::operator=(const TyVector & other)
{
  TyVector tmp(other);
  swap(tmp);
  return *this;
}

void TyVector::swap(TyVector & other)
{
  std::swap(type_, other.type_);
  std::swap(intorname_, other.intorname_);

}

TyVector::~TyVector()
{
  delete(type_);
  delete(intorname_);

}

void TyVector::accept(Visitor *v)
{
  v->visitTyVector(this);
}

TyVector *TyVector::clone() const
{
  return new TyVector(*this);
}



/********************   TEType    ********************/
TEType::TEType(Type *p1)
{
  type_ = p1;

}

TEType::TEType(const TEType & other)
{
  type_ = other.type_->clone();

}

TEType &TEType::operator=(const TEType & other)
{
  TEType tmp(other);
  swap(tmp);
  return *this;
}

void TEType::swap(TEType & other)
{
  std::swap(type_, other.type_);

}

TEType::~TEType()
{
  delete(type_);

}

void TEType::accept(Visitor *v)
{
  v->visitTEType(this);
}

TEType *TEType::clone() const
{
  return new TEType(*this);
}



/********************   TEConstExp    ********************/
TEConstExp::TEConstExp(Exp *p1)
{
  exp_ = p1;

}

TEConstExp::TEConstExp(const TEConstExp & other)
{
  exp_ = other.exp_->clone();

}

TEConstExp &TEConstExp::operator=(const TEConstExp & other)
{
  TEConstExp tmp(other);
  swap(tmp);
  return *this;
}

void TEConstExp::swap(TEConstExp & other)
{
  std::swap(exp_, other.exp_);

}

TEConstExp::~TEConstExp()
{
  delete(exp_);

}

void TEConstExp::accept(Visitor *v)
{
  v->visitTEConstExp(this);
}

TEConstExp *TEConstExp::clone() const
{
  return new TEConstExp(*this);
}



/********************   TemplateArg1    ********************/
TemplateArg1::TemplateArg1(Id p1, TemplateExp *p2)
{
  id_ = p1;
  templateexp_ = p2;

}

TemplateArg1::TemplateArg1(const TemplateArg1 & other)
{
  id_ = other.id_;
  templateexp_ = other.templateexp_->clone();

}

TemplateArg1 &TemplateArg1::operator=(const TemplateArg1 & other)
{
  TemplateArg1 tmp(other);
  swap(tmp);
  return *this;
}

void TemplateArg1::swap(TemplateArg1 & other)
{
  std::swap(id_, other.id_);
  std::swap(templateexp_, other.templateexp_);

}

TemplateArg1::~TemplateArg1()
{
  delete(templateexp_);

}

void TemplateArg1::accept(Visitor *v)
{
  v->visitTemplateArg1(this);
}

TemplateArg1 *TemplateArg1::clone() const
{
  return new TemplateArg1(*this);
}




/********************   ListDef    ********************/

void ListDef::accept(Visitor *v)
{
  v->visitListDef(this);
}


ListDef *ListDef::clone() const
{
  return new ListDef(*this);
}


/********************   ListMetaParam    ********************/

void ListMetaParam::accept(Visitor *v)
{
  v->visitListMetaParam(this);
}


ListMetaParam *ListMetaParam::clone() const
{
  return new ListMetaParam(*this);
}


/********************   ListModDef    ********************/

void ListModDef::accept(Visitor *v)
{
  v->visitListModDef(this);
}


ListModDef *ListModDef::clone() const
{
  return new ListModDef(*this);
}


/********************   ListEventParam    ********************/

void ListEventParam::accept(Visitor *v)
{
  v->visitListEventParam(this);
}


ListEventParam *ListEventParam::clone() const
{
  return new ListEventParam(*this);
}


/********************   ListEventOrList    ********************/

void ListEventOrList::accept(Visitor *v)
{
  v->visitListEventOrList(this);
}


ListEventOrList *ListEventOrList::clone() const
{
  return new ListEventOrList(*this);
}


/********************   ListStructDef    ********************/

void ListStructDef::accept(Visitor *v)
{
  v->visitListStructDef(this);
}


ListStructDef *ListStructDef::clone() const
{
  return new ListStructDef(*this);
}


/********************   ListFuncParam    ********************/

void ListFuncParam::accept(Visitor *v)
{
  v->visitListFuncParam(this);
}


ListFuncParam *ListFuncParam::clone() const
{
  return new ListFuncParam(*this);
}


/********************   ListStatement    ********************/

void ListStatement::accept(Visitor *v)
{
  v->visitListStatement(this);
}


ListStatement *ListStatement::clone() const
{
  return new ListStatement(*this);
}


/********************   ListBlockAttr    ********************/

void ListBlockAttr::accept(Visitor *v)
{
  v->visitListBlockAttr(this);
}


ListBlockAttr *ListBlockAttr::clone() const
{
  return new ListBlockAttr(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}


/********************   ListPackageName    ********************/

void ListPackageName::accept(Visitor *v)
{
  v->visitListPackageName(this);
}


ListPackageName *ListPackageName::clone() const
{
  return new ListPackageName(*this);
}


/********************   ListStructLiteralField    ********************/

void ListStructLiteralField::accept(Visitor *v)
{
  v->visitListStructLiteralField(this);
}


ListStructLiteralField *ListStructLiteralField::clone() const
{
  return new ListStructLiteralField(*this);
}


/********************   ListTemplateArg    ********************/

void ListTemplateArg::accept(Visitor *v)
{
  v->visitListTemplateArg(this);
}


ListTemplateArg *ListTemplateArg::clone() const
{
  return new ListTemplateArg(*this);
}




