#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string Id;


/********************   Forward Declarations    ********************/

class Package;
class Def;
class MetaParamDecl;
class OptionalEqExp;
class MetaParam;
class ModDef;
class ChannelSpecifier;
class EventName;
class EventParam;
class EventOrCond;
class EventOrList;
class StructDef;
class FuncParam;
class OptionalType;
class Statement;
class PushSubDest;
class VarAssignment;
class Block;
class BlockAttr;
class ElseBlock;
class Exp;
class PackageName;
class StructLiteralField;
class IntOrName;
class Type;
class TemplateExp;
class TemplateArg;
class PDefs;
class DefImport;
class DefPackage;
class DefModule;
class DefStruct;
class NoParams;
class SomeParams;
class EqExp;
class NoEqExp;
class MetaParam1;
class DefConst;
class DefReg;
class DefMem;
class DefSubmodule;
class DefInput;
class DefOutput;
class DefInternal;
class DefEvent;
class DefInit;
class DefConnect;
class DefFor;
class DefIf;
class SimpleCS;
class DotCS;
class ArrayDotCS;
class NoEvName;
class EvName;
class EventParamWithName;
class EventParamNoName;
class CSEventCond;
class ListEvOr;
class EventOrListChannelSpecifier;
class DefSubstor;
class DefFunction;
class FuncParam1;
class NoType;
class TypeSpec;
class VarStmt;
class AssignStmt;
class AssignArrStmt;
class IfStmt;
class BlockStmt;
class PushStmt;
class StaticForStmt;
class StaticIfStmt;
class ReturnStmt;
class WaitUntilStmt;
class PushSubreg;
class PushArray;
class PushArrayDot;
class PushReg;
class VarAssign;
class NoVarAssign;
class Block1;
class BlockAttr_atomic;
class BlockAttr_xact;
class ElseIf;
class Else;
class NoElse;
class EVoid;
class ETrue;
class EFalse;
class EInt;
class EDouble;
class EString;
class EStructLiteral;
class EVectorLiteral;
class EId;
class EArrAcc;
class ESlice;
class EDot;
class ETimes;
class EDiv;
class EPlus;
class EMinus;
class ELt;
class EGt;
class ELtEq;
class EGtEq;
class EEq;
class ENEq;
class EAnd;
class EOr;
class PackageNameId;
class StructLiteralField1;
class ConstName;
class Int;
class TyName;
class TyVoid;
class TyType;
class TyNameParams;
class TyArray;
class TyVector;
class TEType;
class TEConstExp;
class TemplateArg1;
class ListDef;
class ListMetaParam;
class ListModDef;
class ListEventParam;
class ListEventOrList;
class ListStructDef;
class ListFuncParam;
class ListStatement;
class ListBlockAttr;
class ListExp;
class ListPackageName;
class ListStructLiteralField;
class ListTemplateArg;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitPackage(Package *p) = 0;
  virtual void visitDef(Def *p) = 0;
  virtual void visitMetaParamDecl(MetaParamDecl *p) = 0;
  virtual void visitOptionalEqExp(OptionalEqExp *p) = 0;
  virtual void visitMetaParam(MetaParam *p) = 0;
  virtual void visitModDef(ModDef *p) = 0;
  virtual void visitChannelSpecifier(ChannelSpecifier *p) = 0;
  virtual void visitEventName(EventName *p) = 0;
  virtual void visitEventParam(EventParam *p) = 0;
  virtual void visitEventOrCond(EventOrCond *p) = 0;
  virtual void visitEventOrList(EventOrList *p) = 0;
  virtual void visitStructDef(StructDef *p) = 0;
  virtual void visitFuncParam(FuncParam *p) = 0;
  virtual void visitOptionalType(OptionalType *p) = 0;
  virtual void visitStatement(Statement *p) = 0;
  virtual void visitPushSubDest(PushSubDest *p) = 0;
  virtual void visitVarAssignment(VarAssignment *p) = 0;
  virtual void visitBlock(Block *p) = 0;
  virtual void visitBlockAttr(BlockAttr *p) = 0;
  virtual void visitElseBlock(ElseBlock *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitPackageName(PackageName *p) = 0;
  virtual void visitStructLiteralField(StructLiteralField *p) = 0;
  virtual void visitIntOrName(IntOrName *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitTemplateExp(TemplateExp *p) = 0;
  virtual void visitTemplateArg(TemplateArg *p) = 0;
  virtual void visitPDefs(PDefs *p) = 0;
  virtual void visitDefImport(DefImport *p) = 0;
  virtual void visitDefPackage(DefPackage *p) = 0;
  virtual void visitDefModule(DefModule *p) = 0;
  virtual void visitDefStruct(DefStruct *p) = 0;
  virtual void visitNoParams(NoParams *p) = 0;
  virtual void visitSomeParams(SomeParams *p) = 0;
  virtual void visitEqExp(EqExp *p) = 0;
  virtual void visitNoEqExp(NoEqExp *p) = 0;
  virtual void visitMetaParam1(MetaParam1 *p) = 0;
  virtual void visitDefConst(DefConst *p) = 0;
  virtual void visitDefReg(DefReg *p) = 0;
  virtual void visitDefMem(DefMem *p) = 0;
  virtual void visitDefSubmodule(DefSubmodule *p) = 0;
  virtual void visitDefInput(DefInput *p) = 0;
  virtual void visitDefOutput(DefOutput *p) = 0;
  virtual void visitDefInternal(DefInternal *p) = 0;
  virtual void visitDefEvent(DefEvent *p) = 0;
  virtual void visitDefInit(DefInit *p) = 0;
  virtual void visitDefConnect(DefConnect *p) = 0;
  virtual void visitDefFor(DefFor *p) = 0;
  virtual void visitDefIf(DefIf *p) = 0;
  virtual void visitSimpleCS(SimpleCS *p) = 0;
  virtual void visitDotCS(DotCS *p) = 0;
  virtual void visitArrayDotCS(ArrayDotCS *p) = 0;
  virtual void visitNoEvName(NoEvName *p) = 0;
  virtual void visitEvName(EvName *p) = 0;
  virtual void visitEventParamWithName(EventParamWithName *p) = 0;
  virtual void visitEventParamNoName(EventParamNoName *p) = 0;
  virtual void visitCSEventCond(CSEventCond *p) = 0;
  virtual void visitListEvOr(ListEvOr *p) = 0;
  virtual void visitEventOrListChannelSpecifier(EventOrListChannelSpecifier *p) = 0;
  virtual void visitDefSubstor(DefSubstor *p) = 0;
  virtual void visitDefFunction(DefFunction *p) = 0;
  virtual void visitFuncParam1(FuncParam1 *p) = 0;
  virtual void visitNoType(NoType *p) = 0;
  virtual void visitTypeSpec(TypeSpec *p) = 0;
  virtual void visitVarStmt(VarStmt *p) = 0;
  virtual void visitAssignStmt(AssignStmt *p) = 0;
  virtual void visitAssignArrStmt(AssignArrStmt *p) = 0;
  virtual void visitIfStmt(IfStmt *p) = 0;
  virtual void visitBlockStmt(BlockStmt *p) = 0;
  virtual void visitPushStmt(PushStmt *p) = 0;
  virtual void visitStaticForStmt(StaticForStmt *p) = 0;
  virtual void visitStaticIfStmt(StaticIfStmt *p) = 0;
  virtual void visitReturnStmt(ReturnStmt *p) = 0;
  virtual void visitWaitUntilStmt(WaitUntilStmt *p) = 0;
  virtual void visitPushSubreg(PushSubreg *p) = 0;
  virtual void visitPushArray(PushArray *p) = 0;
  virtual void visitPushArrayDot(PushArrayDot *p) = 0;
  virtual void visitPushReg(PushReg *p) = 0;
  virtual void visitVarAssign(VarAssign *p) = 0;
  virtual void visitNoVarAssign(NoVarAssign *p) = 0;
  virtual void visitBlock1(Block1 *p) = 0;
  virtual void visitBlockAttr_atomic(BlockAttr_atomic *p) = 0;
  virtual void visitBlockAttr_xact(BlockAttr_xact *p) = 0;
  virtual void visitElseIf(ElseIf *p) = 0;
  virtual void visitElse(Else *p) = 0;
  virtual void visitNoElse(NoElse *p) = 0;
  virtual void visitEVoid(EVoid *p) = 0;
  virtual void visitETrue(ETrue *p) = 0;
  virtual void visitEFalse(EFalse *p) = 0;
  virtual void visitEInt(EInt *p) = 0;
  virtual void visitEDouble(EDouble *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitEStructLiteral(EStructLiteral *p) = 0;
  virtual void visitEVectorLiteral(EVectorLiteral *p) = 0;
  virtual void visitEId(EId *p) = 0;
  virtual void visitEArrAcc(EArrAcc *p) = 0;
  virtual void visitESlice(ESlice *p) = 0;
  virtual void visitEDot(EDot *p) = 0;
  virtual void visitETimes(ETimes *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitEPlus(EPlus *p) = 0;
  virtual void visitEMinus(EMinus *p) = 0;
  virtual void visitELt(ELt *p) = 0;
  virtual void visitEGt(EGt *p) = 0;
  virtual void visitELtEq(ELtEq *p) = 0;
  virtual void visitEGtEq(EGtEq *p) = 0;
  virtual void visitEEq(EEq *p) = 0;
  virtual void visitENEq(ENEq *p) = 0;
  virtual void visitEAnd(EAnd *p) = 0;
  virtual void visitEOr(EOr *p) = 0;
  virtual void visitPackageNameId(PackageNameId *p) = 0;
  virtual void visitStructLiteralField1(StructLiteralField1 *p) = 0;
  virtual void visitConstName(ConstName *p) = 0;
  virtual void visitInt(Int *p) = 0;
  virtual void visitTyName(TyName *p) = 0;
  virtual void visitTyVoid(TyVoid *p) = 0;
  virtual void visitTyType(TyType *p) = 0;
  virtual void visitTyNameParams(TyNameParams *p) = 0;
  virtual void visitTyArray(TyArray *p) = 0;
  virtual void visitTyVector(TyVector *p) = 0;
  virtual void visitTEType(TEType *p) = 0;
  virtual void visitTEConstExp(TEConstExp *p) = 0;
  virtual void visitTemplateArg1(TemplateArg1 *p) = 0;
  virtual void visitListDef(ListDef *p) = 0;
  virtual void visitListMetaParam(ListMetaParam *p) = 0;
  virtual void visitListModDef(ListModDef *p) = 0;
  virtual void visitListEventParam(ListEventParam *p) = 0;
  virtual void visitListEventOrList(ListEventOrList *p) = 0;
  virtual void visitListStructDef(ListStructDef *p) = 0;
  virtual void visitListFuncParam(ListFuncParam *p) = 0;
  virtual void visitListStatement(ListStatement *p) = 0;
  virtual void visitListBlockAttr(ListBlockAttr *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;
  virtual void visitListPackageName(ListPackageName *p) = 0;
  virtual void visitListStructLiteralField(ListStructLiteralField *p) = 0;
  virtual void visitListTemplateArg(ListTemplateArg *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitId(Id x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Package : public Visitable
{
public:
  virtual Package *clone() const = 0;
  int line_number;
};

class Def : public Visitable
{
public:
  virtual Def *clone() const = 0;
  int line_number;
};

class MetaParamDecl : public Visitable
{
public:
  virtual MetaParamDecl *clone() const = 0;
  int line_number;
};

class OptionalEqExp : public Visitable
{
public:
  virtual OptionalEqExp *clone() const = 0;
  int line_number;
};

class MetaParam : public Visitable
{
public:
  virtual MetaParam *clone() const = 0;
  int line_number;
};

class ModDef : public Visitable
{
public:
  virtual ModDef *clone() const = 0;
  int line_number;
};

class ChannelSpecifier : public Visitable
{
public:
  virtual ChannelSpecifier *clone() const = 0;
  int line_number;
};

class EventName : public Visitable
{
public:
  virtual EventName *clone() const = 0;
  int line_number;
};

class EventParam : public Visitable
{
public:
  virtual EventParam *clone() const = 0;
  int line_number;
};

class EventOrCond : public Visitable
{
public:
  virtual EventOrCond *clone() const = 0;
  int line_number;
};

class EventOrList : public Visitable
{
public:
  virtual EventOrList *clone() const = 0;
  int line_number;
};

class StructDef : public Visitable
{
public:
  virtual StructDef *clone() const = 0;
  int line_number;
};

class FuncParam : public Visitable
{
public:
  virtual FuncParam *clone() const = 0;
  int line_number;
};

class OptionalType : public Visitable
{
public:
  virtual OptionalType *clone() const = 0;
  int line_number;
};

class Statement : public Visitable
{
public:
  virtual Statement *clone() const = 0;
  int line_number;
};

class PushSubDest : public Visitable
{
public:
  virtual PushSubDest *clone() const = 0;
  int line_number;
};

class VarAssignment : public Visitable
{
public:
  virtual VarAssignment *clone() const = 0;
  int line_number;
};

class Block : public Visitable
{
public:
  virtual Block *clone() const = 0;
  int line_number;
};

class BlockAttr : public Visitable
{
public:
  virtual BlockAttr *clone() const = 0;
  int line_number;
};

class ElseBlock : public Visitable
{
public:
  virtual ElseBlock *clone() const = 0;
  int line_number;
};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;
  int line_number;
};

class PackageName : public Visitable
{
public:
  virtual PackageName *clone() const = 0;
  int line_number;
};

class StructLiteralField : public Visitable
{
public:
  virtual StructLiteralField *clone() const = 0;
  int line_number;
};

class IntOrName : public Visitable
{
public:
  virtual IntOrName *clone() const = 0;
  int line_number;
};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;
  int line_number;
};

class TemplateExp : public Visitable
{
public:
  virtual TemplateExp *clone() const = 0;
  int line_number;
};

class TemplateArg : public Visitable
{
public:
  virtual TemplateArg *clone() const = 0;
  int line_number;
};



class PDefs : public Package
{
public:
  ListDef *listdef_;

  PDefs(const PDefs &);
  PDefs &operator=(const PDefs &);
  PDefs(ListDef *p1);
  ~PDefs();
  virtual void accept(Visitor *v);
  virtual PDefs *clone() const;
  void swap(PDefs &);
};

class DefImport : public Def
{
public:
  ListPackageName *listpackagename_;

  DefImport(const DefImport &);
  DefImport &operator=(const DefImport &);
  DefImport(ListPackageName *p1);
  ~DefImport();
  virtual void accept(Visitor *v);
  virtual DefImport *clone() const;
  void swap(DefImport &);
};

class DefPackage : public Def
{
public:
  ListPackageName *listpackagename_;

  DefPackage(const DefPackage &);
  DefPackage &operator=(const DefPackage &);
  DefPackage(ListPackageName *p1);
  ~DefPackage();
  virtual void accept(Visitor *v);
  virtual DefPackage *clone() const;
  void swap(DefPackage &);
};

class DefModule : public Def
{
public:
  Id id_;
  MetaParamDecl *metaparamdecl_;
  ListModDef *listmoddef_;

  DefModule(const DefModule &);
  DefModule &operator=(const DefModule &);
  DefModule(Id p1, MetaParamDecl *p2, ListModDef *p3);
  ~DefModule();
  virtual void accept(Visitor *v);
  virtual DefModule *clone() const;
  void swap(DefModule &);
};

class DefStruct : public Def
{
public:
  Id id_;
  MetaParamDecl *metaparamdecl_;
  ListStructDef *liststructdef_;

  DefStruct(const DefStruct &);
  DefStruct &operator=(const DefStruct &);
  DefStruct(Id p1, MetaParamDecl *p2, ListStructDef *p3);
  ~DefStruct();
  virtual void accept(Visitor *v);
  virtual DefStruct *clone() const;
  void swap(DefStruct &);
};

class NoParams : public MetaParamDecl
{
public:

  NoParams(const NoParams &);
  NoParams &operator=(const NoParams &);
  NoParams();
  ~NoParams();
  virtual void accept(Visitor *v);
  virtual NoParams *clone() const;
  void swap(NoParams &);
};

class SomeParams : public MetaParamDecl
{
public:
  ListMetaParam *listmetaparam_;

  SomeParams(const SomeParams &);
  SomeParams &operator=(const SomeParams &);
  SomeParams(ListMetaParam *p1);
  ~SomeParams();
  virtual void accept(Visitor *v);
  virtual SomeParams *clone() const;
  void swap(SomeParams &);
};

class EqExp : public OptionalEqExp
{
public:
  Exp *exp_;

  EqExp(const EqExp &);
  EqExp &operator=(const EqExp &);
  EqExp(Exp *p1);
  ~EqExp();
  virtual void accept(Visitor *v);
  virtual EqExp *clone() const;
  void swap(EqExp &);
};

class NoEqExp : public OptionalEqExp
{
public:

  NoEqExp(const NoEqExp &);
  NoEqExp &operator=(const NoEqExp &);
  NoEqExp();
  ~NoEqExp();
  virtual void accept(Visitor *v);
  virtual NoEqExp *clone() const;
  void swap(NoEqExp &);
};

class MetaParam1 : public MetaParam
{
public:
  Type *type_;
  Id id_;
  OptionalEqExp *optionaleqexp_;

  MetaParam1(const MetaParam1 &);
  MetaParam1 &operator=(const MetaParam1 &);
  MetaParam1(Type *p1, Id p2, OptionalEqExp *p3);
  ~MetaParam1();
  virtual void accept(Visitor *v);
  virtual MetaParam1 *clone() const;
  void swap(MetaParam1 &);
};

class DefConst : public ModDef
{
public:
  Type *type_;
  Id id_;
  OptionalEqExp *optionaleqexp_;

  DefConst(const DefConst &);
  DefConst &operator=(const DefConst &);
  DefConst(Type *p1, Id p2, OptionalEqExp *p3);
  ~DefConst();
  virtual void accept(Visitor *v);
  virtual DefConst *clone() const;
  void swap(DefConst &);
};

class DefReg : public ModDef
{
public:
  Type *type_;
  Id id_;

  DefReg(const DefReg &);
  DefReg &operator=(const DefReg &);
  DefReg(Type *p1, Id p2);
  ~DefReg();
  virtual void accept(Visitor *v);
  virtual DefReg *clone() const;
  void swap(DefReg &);
};

class DefMem : public ModDef
{
public:
  Type *type_;
  Id id_;

  DefMem(const DefMem &);
  DefMem &operator=(const DefMem &);
  DefMem(Type *p1, Id p2);
  ~DefMem();
  virtual void accept(Visitor *v);
  virtual DefMem *clone() const;
  void swap(DefMem &);
};

class DefSubmodule : public ModDef
{
public:
  Type *type_;
  Id id_;

  DefSubmodule(const DefSubmodule &);
  DefSubmodule &operator=(const DefSubmodule &);
  DefSubmodule(Type *p1, Id p2);
  ~DefSubmodule();
  virtual void accept(Visitor *v);
  virtual DefSubmodule *clone() const;
  void swap(DefSubmodule &);
};

class DefInput : public ModDef
{
public:
  Type *type_;
  Id id_;

  DefInput(const DefInput &);
  DefInput &operator=(const DefInput &);
  DefInput(Type *p1, Id p2);
  ~DefInput();
  virtual void accept(Visitor *v);
  virtual DefInput *clone() const;
  void swap(DefInput &);
};

class DefOutput : public ModDef
{
public:
  Type *type_;
  Id id_;

  DefOutput(const DefOutput &);
  DefOutput &operator=(const DefOutput &);
  DefOutput(Type *p1, Id p2);
  ~DefOutput();
  virtual void accept(Visitor *v);
  virtual DefOutput *clone() const;
  void swap(DefOutput &);
};

class DefInternal : public ModDef
{
public:
  Type *type_;
  Id id_;

  DefInternal(const DefInternal &);
  DefInternal &operator=(const DefInternal &);
  DefInternal(Type *p1, Id p2);
  ~DefInternal();
  virtual void accept(Visitor *v);
  virtual DefInternal *clone() const;
  void swap(DefInternal &);
};

class DefEvent : public ModDef
{
public:
  EventName *eventname_;
  ListEventParam *listeventparam_;
  Block *block_;

  DefEvent(const DefEvent &);
  DefEvent &operator=(const DefEvent &);
  DefEvent(EventName *p1, ListEventParam *p2, Block *p3);
  ~DefEvent();
  virtual void accept(Visitor *v);
  virtual DefEvent *clone() const;
  void swap(DefEvent &);
};

class DefInit : public ModDef
{
public:
  EventName *eventname_;
  Block *block_;

  DefInit(const DefInit &);
  DefInit &operator=(const DefInit &);
  DefInit(EventName *p1, Block *p2);
  ~DefInit();
  virtual void accept(Visitor *v);
  virtual DefInit *clone() const;
  void swap(DefInit &);
};

class DefConnect : public ModDef
{
public:
  ChannelSpecifier *channelspecifier_1;
  ChannelSpecifier *channelspecifier_2;

  DefConnect(const DefConnect &);
  DefConnect &operator=(const DefConnect &);
  DefConnect(ChannelSpecifier *p1, ChannelSpecifier *p2);
  ~DefConnect();
  virtual void accept(Visitor *v);
  virtual DefConnect *clone() const;
  void swap(DefConnect &);
};

class DefFor : public ModDef
{
public:
  Id id_;
  Exp *exp_1;
  Exp *exp_2;
  ListModDef *listmoddef_;

  DefFor(const DefFor &);
  DefFor &operator=(const DefFor &);
  DefFor(Id p1, Exp *p2, Exp *p3, ListModDef *p4);
  ~DefFor();
  virtual void accept(Visitor *v);
  virtual DefFor *clone() const;
  void swap(DefFor &);
};

class DefIf : public ModDef
{
public:
  Exp *exp_;
  ListModDef *listmoddef_;

  DefIf(const DefIf &);
  DefIf &operator=(const DefIf &);
  DefIf(Exp *p1, ListModDef *p2);
  ~DefIf();
  virtual void accept(Visitor *v);
  virtual DefIf *clone() const;
  void swap(DefIf &);
};

class SimpleCS : public ChannelSpecifier
{
public:
  Id id_;

  SimpleCS(const SimpleCS &);
  SimpleCS &operator=(const SimpleCS &);
  SimpleCS(Id p1);
  ~SimpleCS();
  virtual void accept(Visitor *v);
  virtual SimpleCS *clone() const;
  void swap(SimpleCS &);
};

class DotCS : public ChannelSpecifier
{
public:
  Id id_1;
  Id id_2;

  DotCS(const DotCS &);
  DotCS &operator=(const DotCS &);
  DotCS(Id p1, Id p2);
  ~DotCS();
  virtual void accept(Visitor *v);
  virtual DotCS *clone() const;
  void swap(DotCS &);
};

class ArrayDotCS : public ChannelSpecifier
{
public:
  Id id_1;
  Exp *exp_;
  Id id_2;

  ArrayDotCS(const ArrayDotCS &);
  ArrayDotCS &operator=(const ArrayDotCS &);
  ArrayDotCS(Id p1, Exp *p2, Id p3);
  ~ArrayDotCS();
  virtual void accept(Visitor *v);
  virtual ArrayDotCS *clone() const;
  void swap(ArrayDotCS &);
};

class NoEvName : public EventName
{
public:

  NoEvName(const NoEvName &);
  NoEvName &operator=(const NoEvName &);
  NoEvName();
  ~NoEvName();
  virtual void accept(Visitor *v);
  virtual NoEvName *clone() const;
  void swap(NoEvName &);
};

class EvName : public EventName
{
public:
  Id id_;

  EvName(const EvName &);
  EvName &operator=(const EvName &);
  EvName(Id p1);
  ~EvName();
  virtual void accept(Visitor *v);
  virtual EvName *clone() const;
  void swap(EvName &);
};

class EventParamWithName : public EventParam
{
public:
  EventOrCond *eventorcond_;
  Id id_;

  EventParamWithName(const EventParamWithName &);
  EventParamWithName &operator=(const EventParamWithName &);
  EventParamWithName(EventOrCond *p1, Id p2);
  ~EventParamWithName();
  virtual void accept(Visitor *v);
  virtual EventParamWithName *clone() const;
  void swap(EventParamWithName &);
};

class EventParamNoName : public EventParam
{
public:
  EventOrCond *eventorcond_;

  EventParamNoName(const EventParamNoName &);
  EventParamNoName &operator=(const EventParamNoName &);
  EventParamNoName(EventOrCond *p1);
  ~EventParamNoName();
  virtual void accept(Visitor *v);
  virtual EventParamNoName *clone() const;
  void swap(EventParamNoName &);
};

class CSEventCond : public EventOrCond
{
public:
  ChannelSpecifier *channelspecifier_;

  CSEventCond(const CSEventCond &);
  CSEventCond &operator=(const CSEventCond &);
  CSEventCond(ChannelSpecifier *p1);
  ~CSEventCond();
  virtual void accept(Visitor *v);
  virtual CSEventCond *clone() const;
  void swap(CSEventCond &);
};

class ListEvOr : public EventOrCond
{
public:
  ListEventOrList *listeventorlist_;

  ListEvOr(const ListEvOr &);
  ListEvOr &operator=(const ListEvOr &);
  ListEvOr(ListEventOrList *p1);
  ~ListEvOr();
  virtual void accept(Visitor *v);
  virtual ListEvOr *clone() const;
  void swap(ListEvOr &);
};

class EventOrListChannelSpecifier : public EventOrList
{
public:
  ChannelSpecifier *channelspecifier_;

  EventOrListChannelSpecifier(const EventOrListChannelSpecifier &);
  EventOrListChannelSpecifier &operator=(const EventOrListChannelSpecifier &);
  EventOrListChannelSpecifier(ChannelSpecifier *p1);
  ~EventOrListChannelSpecifier();
  virtual void accept(Visitor *v);
  virtual EventOrListChannelSpecifier *clone() const;
  void swap(EventOrListChannelSpecifier &);
};

class DefSubstor : public StructDef
{
public:
  Type *type_;
  Id id_;

  DefSubstor(const DefSubstor &);
  DefSubstor &operator=(const DefSubstor &);
  DefSubstor(Type *p1, Id p2);
  ~DefSubstor();
  virtual void accept(Visitor *v);
  virtual DefSubstor *clone() const;
  void swap(DefSubstor &);
};

class DefFunction : public StructDef
{
public:
  Type *type_;
  Id id_;
  ListFuncParam *listfuncparam_;
  ListStatement *liststatement_;

  DefFunction(const DefFunction &);
  DefFunction &operator=(const DefFunction &);
  DefFunction(Type *p1, Id p2, ListFuncParam *p3, ListStatement *p4);
  ~DefFunction();
  virtual void accept(Visitor *v);
  virtual DefFunction *clone() const;
  void swap(DefFunction &);
};

class FuncParam1 : public FuncParam
{
public:
  Type *type_;
  Id id_;

  FuncParam1(const FuncParam1 &);
  FuncParam1 &operator=(const FuncParam1 &);
  FuncParam1(Type *p1, Id p2);
  ~FuncParam1();
  virtual void accept(Visitor *v);
  virtual FuncParam1 *clone() const;
  void swap(FuncParam1 &);
};

class NoType : public OptionalType
{
public:

  NoType(const NoType &);
  NoType &operator=(const NoType &);
  NoType();
  ~NoType();
  virtual void accept(Visitor *v);
  virtual NoType *clone() const;
  void swap(NoType &);
};

class TypeSpec : public OptionalType
{
public:
  Type *type_;

  TypeSpec(const TypeSpec &);
  TypeSpec &operator=(const TypeSpec &);
  TypeSpec(Type *p1);
  ~TypeSpec();
  virtual void accept(Visitor *v);
  virtual TypeSpec *clone() const;
  void swap(TypeSpec &);
};

class VarStmt : public Statement
{
public:
  OptionalType *optionaltype_;
  Id id_;
  VarAssignment *varassignment_;

  VarStmt(const VarStmt &);
  VarStmt &operator=(const VarStmt &);
  VarStmt(OptionalType *p1, Id p2, VarAssignment *p3);
  ~VarStmt();
  virtual void accept(Visitor *v);
  virtual VarStmt *clone() const;
  void swap(VarStmt &);
};

class AssignStmt : public Statement
{
public:
  Id id_;
  Exp *exp_;

  AssignStmt(const AssignStmt &);
  AssignStmt &operator=(const AssignStmt &);
  AssignStmt(Id p1, Exp *p2);
  ~AssignStmt();
  virtual void accept(Visitor *v);
  virtual AssignStmt *clone() const;
  void swap(AssignStmt &);
};

class AssignArrStmt : public Statement
{
public:
  Id id_;
  Exp *exp_1;
  Exp *exp_2;

  AssignArrStmt(const AssignArrStmt &);
  AssignArrStmt &operator=(const AssignArrStmt &);
  AssignArrStmt(Id p1, Exp *p2, Exp *p3);
  ~AssignArrStmt();
  virtual void accept(Visitor *v);
  virtual AssignArrStmt *clone() const;
  void swap(AssignArrStmt &);
};

class IfStmt : public Statement
{
public:
  Exp *exp_;
  Block *block_;
  ElseBlock *elseblock_;

  IfStmt(const IfStmt &);
  IfStmt &operator=(const IfStmt &);
  IfStmt(Exp *p1, Block *p2, ElseBlock *p3);
  ~IfStmt();
  virtual void accept(Visitor *v);
  virtual IfStmt *clone() const;
  void swap(IfStmt &);
};

class BlockStmt : public Statement
{
public:
  Block *block_;

  BlockStmt(const BlockStmt &);
  BlockStmt &operator=(const BlockStmt &);
  BlockStmt(Block *p1);
  ~BlockStmt();
  virtual void accept(Visitor *v);
  virtual BlockStmt *clone() const;
  void swap(BlockStmt &);
};

class PushStmt : public Statement
{
public:
  Id id_;
  PushSubDest *pushsubdest_;
  Exp *exp_;

  PushStmt(const PushStmt &);
  PushStmt &operator=(const PushStmt &);
  PushStmt(Id p1, PushSubDest *p2, Exp *p3);
  ~PushStmt();
  virtual void accept(Visitor *v);
  virtual PushStmt *clone() const;
  void swap(PushStmt &);
};

class StaticForStmt : public Statement
{
public:
  Id id_;
  Exp *exp_1;
  Exp *exp_2;
  Block *block_;

  StaticForStmt(const StaticForStmt &);
  StaticForStmt &operator=(const StaticForStmt &);
  StaticForStmt(Id p1, Exp *p2, Exp *p3, Block *p4);
  ~StaticForStmt();
  virtual void accept(Visitor *v);
  virtual StaticForStmt *clone() const;
  void swap(StaticForStmt &);
};

class StaticIfStmt : public Statement
{
public:
  Exp *exp_;
  Block *block_;

  StaticIfStmt(const StaticIfStmt &);
  StaticIfStmt &operator=(const StaticIfStmt &);
  StaticIfStmt(Exp *p1, Block *p2);
  ~StaticIfStmt();
  virtual void accept(Visitor *v);
  virtual StaticIfStmt *clone() const;
  void swap(StaticIfStmt &);
};

class ReturnStmt : public Statement
{
public:
  Exp *exp_;

  ReturnStmt(const ReturnStmt &);
  ReturnStmt &operator=(const ReturnStmt &);
  ReturnStmt(Exp *p1);
  ~ReturnStmt();
  virtual void accept(Visitor *v);
  virtual ReturnStmt *clone() const;
  void swap(ReturnStmt &);
};

class WaitUntilStmt : public Statement
{
public:
  Exp *exp_;

  WaitUntilStmt(const WaitUntilStmt &);
  WaitUntilStmt &operator=(const WaitUntilStmt &);
  WaitUntilStmt(Exp *p1);
  ~WaitUntilStmt();
  virtual void accept(Visitor *v);
  virtual WaitUntilStmt *clone() const;
  void swap(WaitUntilStmt &);
};

class PushSubreg : public PushSubDest
{
public:
  Id id_;

  PushSubreg(const PushSubreg &);
  PushSubreg &operator=(const PushSubreg &);
  PushSubreg(Id p1);
  ~PushSubreg();
  virtual void accept(Visitor *v);
  virtual PushSubreg *clone() const;
  void swap(PushSubreg &);
};

class PushArray : public PushSubDest
{
public:
  Exp *exp_;

  PushArray(const PushArray &);
  PushArray &operator=(const PushArray &);
  PushArray(Exp *p1);
  ~PushArray();
  virtual void accept(Visitor *v);
  virtual PushArray *clone() const;
  void swap(PushArray &);
};

class PushArrayDot : public PushSubDest
{
public:
  Exp *exp_;
  Id id_;

  PushArrayDot(const PushArrayDot &);
  PushArrayDot &operator=(const PushArrayDot &);
  PushArrayDot(Exp *p1, Id p2);
  ~PushArrayDot();
  virtual void accept(Visitor *v);
  virtual PushArrayDot *clone() const;
  void swap(PushArrayDot &);
};

class PushReg : public PushSubDest
{
public:

  PushReg(const PushReg &);
  PushReg &operator=(const PushReg &);
  PushReg();
  ~PushReg();
  virtual void accept(Visitor *v);
  virtual PushReg *clone() const;
  void swap(PushReg &);
};

class VarAssign : public VarAssignment
{
public:
  Exp *exp_;

  VarAssign(const VarAssign &);
  VarAssign &operator=(const VarAssign &);
  VarAssign(Exp *p1);
  ~VarAssign();
  virtual void accept(Visitor *v);
  virtual VarAssign *clone() const;
  void swap(VarAssign &);
};

class NoVarAssign : public VarAssignment
{
public:

  NoVarAssign(const NoVarAssign &);
  NoVarAssign &operator=(const NoVarAssign &);
  NoVarAssign();
  ~NoVarAssign();
  virtual void accept(Visitor *v);
  virtual NoVarAssign *clone() const;
  void swap(NoVarAssign &);
};

class Block1 : public Block
{
public:
  ListBlockAttr *listblockattr_;
  ListStatement *liststatement_;

  Block1(const Block1 &);
  Block1 &operator=(const Block1 &);
  Block1(ListBlockAttr *p1, ListStatement *p2);
  ~Block1();
  virtual void accept(Visitor *v);
  virtual Block1 *clone() const;
  void swap(Block1 &);
};

class BlockAttr_atomic : public BlockAttr
{
public:

  BlockAttr_atomic(const BlockAttr_atomic &);
  BlockAttr_atomic &operator=(const BlockAttr_atomic &);
  BlockAttr_atomic();
  ~BlockAttr_atomic();
  virtual void accept(Visitor *v);
  virtual BlockAttr_atomic *clone() const;
  void swap(BlockAttr_atomic &);
};

class BlockAttr_xact : public BlockAttr
{
public:

  BlockAttr_xact(const BlockAttr_xact &);
  BlockAttr_xact &operator=(const BlockAttr_xact &);
  BlockAttr_xact();
  ~BlockAttr_xact();
  virtual void accept(Visitor *v);
  virtual BlockAttr_xact *clone() const;
  void swap(BlockAttr_xact &);
};

class ElseIf : public ElseBlock
{
public:
  Exp *exp_;
  Block *block_;
  ElseBlock *elseblock_;

  ElseIf(const ElseIf &);
  ElseIf &operator=(const ElseIf &);
  ElseIf(Exp *p1, Block *p2, ElseBlock *p3);
  ~ElseIf();
  virtual void accept(Visitor *v);
  virtual ElseIf *clone() const;
  void swap(ElseIf &);
};

class Else : public ElseBlock
{
public:
  Block *block_;

  Else(const Else &);
  Else &operator=(const Else &);
  Else(Block *p1);
  ~Else();
  virtual void accept(Visitor *v);
  virtual Else *clone() const;
  void swap(Else &);
};

class NoElse : public ElseBlock
{
public:

  NoElse(const NoElse &);
  NoElse &operator=(const NoElse &);
  NoElse();
  ~NoElse();
  virtual void accept(Visitor *v);
  virtual NoElse *clone() const;
  void swap(NoElse &);
};

class EVoid : public Exp
{
public:

  EVoid(const EVoid &);
  EVoid &operator=(const EVoid &);
  EVoid();
  ~EVoid();
  virtual void accept(Visitor *v);
  virtual EVoid *clone() const;
  void swap(EVoid &);
};

class ETrue : public Exp
{
public:

  ETrue(const ETrue &);
  ETrue &operator=(const ETrue &);
  ETrue();
  ~ETrue();
  virtual void accept(Visitor *v);
  virtual ETrue *clone() const;
  void swap(ETrue &);
};

class EFalse : public Exp
{
public:

  EFalse(const EFalse &);
  EFalse &operator=(const EFalse &);
  EFalse();
  ~EFalse();
  virtual void accept(Visitor *v);
  virtual EFalse *clone() const;
  void swap(EFalse &);
};

class EInt : public Exp
{
public:
  Integer integer_;

  EInt(const EInt &);
  EInt &operator=(const EInt &);
  EInt(Integer p1);
  ~EInt();
  virtual void accept(Visitor *v);
  virtual EInt *clone() const;
  void swap(EInt &);
};

class EDouble : public Exp
{
public:
  Double double_;

  EDouble(const EDouble &);
  EDouble &operator=(const EDouble &);
  EDouble(Double p1);
  ~EDouble();
  virtual void accept(Visitor *v);
  virtual EDouble *clone() const;
  void swap(EDouble &);
};

class EString : public Exp
{
public:
  String string_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(String p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual EString *clone() const;
  void swap(EString &);
};

class EStructLiteral : public Exp
{
public:
  Type *type_;
  ListStructLiteralField *liststructliteralfield_;

  EStructLiteral(const EStructLiteral &);
  EStructLiteral &operator=(const EStructLiteral &);
  EStructLiteral(Type *p1, ListStructLiteralField *p2);
  ~EStructLiteral();
  virtual void accept(Visitor *v);
  virtual EStructLiteral *clone() const;
  void swap(EStructLiteral &);
};

class EVectorLiteral : public Exp
{
public:
  ListExp *listexp_;

  EVectorLiteral(const EVectorLiteral &);
  EVectorLiteral &operator=(const EVectorLiteral &);
  EVectorLiteral(ListExp *p1);
  ~EVectorLiteral();
  virtual void accept(Visitor *v);
  virtual EVectorLiteral *clone() const;
  void swap(EVectorLiteral &);
};

class EId : public Exp
{
public:
  Id id_;

  EId(const EId &);
  EId &operator=(const EId &);
  EId(Id p1);
  ~EId();
  virtual void accept(Visitor *v);
  virtual EId *clone() const;
  void swap(EId &);
};

class EArrAcc : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EArrAcc(const EArrAcc &);
  EArrAcc &operator=(const EArrAcc &);
  EArrAcc(Exp *p1, Exp *p2);
  ~EArrAcc();
  virtual void accept(Visitor *v);
  virtual EArrAcc *clone() const;
  void swap(EArrAcc &);
};

class ESlice : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;
  Exp *exp_3;

  ESlice(const ESlice &);
  ESlice &operator=(const ESlice &);
  ESlice(Exp *p1, Exp *p2, Exp *p3);
  ~ESlice();
  virtual void accept(Visitor *v);
  virtual ESlice *clone() const;
  void swap(ESlice &);
};

class EDot : public Exp
{
public:
  Exp *exp_;
  Id id_;

  EDot(const EDot &);
  EDot &operator=(const EDot &);
  EDot(Exp *p1, Id p2);
  ~EDot();
  virtual void accept(Visitor *v);
  virtual EDot *clone() const;
  void swap(EDot &);
};

class ETimes : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ETimes(const ETimes &);
  ETimes &operator=(const ETimes &);
  ETimes(Exp *p1, Exp *p2);
  ~ETimes();
  virtual void accept(Visitor *v);
  virtual ETimes *clone() const;
  void swap(ETimes &);
};

class EDiv : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Exp *p1, Exp *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual EDiv *clone() const;
  void swap(EDiv &);
};

class EPlus : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EPlus(const EPlus &);
  EPlus &operator=(const EPlus &);
  EPlus(Exp *p1, Exp *p2);
  ~EPlus();
  virtual void accept(Visitor *v);
  virtual EPlus *clone() const;
  void swap(EPlus &);
};

class EMinus : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMinus(const EMinus &);
  EMinus &operator=(const EMinus &);
  EMinus(Exp *p1, Exp *p2);
  ~EMinus();
  virtual void accept(Visitor *v);
  virtual EMinus *clone() const;
  void swap(EMinus &);
};

class ELt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELt(const ELt &);
  ELt &operator=(const ELt &);
  ELt(Exp *p1, Exp *p2);
  ~ELt();
  virtual void accept(Visitor *v);
  virtual ELt *clone() const;
  void swap(ELt &);
};

class EGt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGt(const EGt &);
  EGt &operator=(const EGt &);
  EGt(Exp *p1, Exp *p2);
  ~EGt();
  virtual void accept(Visitor *v);
  virtual EGt *clone() const;
  void swap(EGt &);
};

class ELtEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELtEq(const ELtEq &);
  ELtEq &operator=(const ELtEq &);
  ELtEq(Exp *p1, Exp *p2);
  ~ELtEq();
  virtual void accept(Visitor *v);
  virtual ELtEq *clone() const;
  void swap(ELtEq &);
};

class EGtEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGtEq(const EGtEq &);
  EGtEq &operator=(const EGtEq &);
  EGtEq(Exp *p1, Exp *p2);
  ~EGtEq();
  virtual void accept(Visitor *v);
  virtual EGtEq *clone() const;
  void swap(EGtEq &);
};

class EEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EEq(const EEq &);
  EEq &operator=(const EEq &);
  EEq(Exp *p1, Exp *p2);
  ~EEq();
  virtual void accept(Visitor *v);
  virtual EEq *clone() const;
  void swap(EEq &);
};

class ENEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ENEq(const ENEq &);
  ENEq &operator=(const ENEq &);
  ENEq(Exp *p1, Exp *p2);
  ~ENEq();
  virtual void accept(Visitor *v);
  virtual ENEq *clone() const;
  void swap(ENEq &);
};

class EAnd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Exp *p1, Exp *p2);
  ~EAnd();
  virtual void accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);
};

class EOr : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Exp *p1, Exp *p2);
  ~EOr();
  virtual void accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);
};

class PackageNameId : public PackageName
{
public:
  Id id_;

  PackageNameId(const PackageNameId &);
  PackageNameId &operator=(const PackageNameId &);
  PackageNameId(Id p1);
  ~PackageNameId();
  virtual void accept(Visitor *v);
  virtual PackageNameId *clone() const;
  void swap(PackageNameId &);
};

class StructLiteralField1 : public StructLiteralField
{
public:
  Id id_;
  Exp *exp_;

  StructLiteralField1(const StructLiteralField1 &);
  StructLiteralField1 &operator=(const StructLiteralField1 &);
  StructLiteralField1(Id p1, Exp *p2);
  ~StructLiteralField1();
  virtual void accept(Visitor *v);
  virtual StructLiteralField1 *clone() const;
  void swap(StructLiteralField1 &);
};

class ConstName : public IntOrName
{
public:
  Id id_;

  ConstName(const ConstName &);
  ConstName &operator=(const ConstName &);
  ConstName(Id p1);
  ~ConstName();
  virtual void accept(Visitor *v);
  virtual ConstName *clone() const;
  void swap(ConstName &);
};

class Int : public IntOrName
{
public:
  Integer integer_;

  Int(const Int &);
  Int &operator=(const Int &);
  Int(Integer p1);
  ~Int();
  virtual void accept(Visitor *v);
  virtual Int *clone() const;
  void swap(Int &);
};

class TyName : public Type
{
public:
  Id id_;

  TyName(const TyName &);
  TyName &operator=(const TyName &);
  TyName(Id p1);
  ~TyName();
  virtual void accept(Visitor *v);
  virtual TyName *clone() const;
  void swap(TyName &);
};

class TyVoid : public Type
{
public:

  TyVoid(const TyVoid &);
  TyVoid &operator=(const TyVoid &);
  TyVoid();
  ~TyVoid();
  virtual void accept(Visitor *v);
  virtual TyVoid *clone() const;
  void swap(TyVoid &);
};

class TyType : public Type
{
public:

  TyType(const TyType &);
  TyType &operator=(const TyType &);
  TyType();
  ~TyType();
  virtual void accept(Visitor *v);
  virtual TyType *clone() const;
  void swap(TyType &);
};

class TyNameParams : public Type
{
public:
  Id id_;
  ListTemplateArg *listtemplatearg_;

  TyNameParams(const TyNameParams &);
  TyNameParams &operator=(const TyNameParams &);
  TyNameParams(Id p1, ListTemplateArg *p2);
  ~TyNameParams();
  virtual void accept(Visitor *v);
  virtual TyNameParams *clone() const;
  void swap(TyNameParams &);
};

class TyArray : public Type
{
public:
  Type *type_;
  IntOrName *intorname_;

  TyArray(const TyArray &);
  TyArray &operator=(const TyArray &);
  TyArray(Type *p1, IntOrName *p2);
  ~TyArray();
  virtual void accept(Visitor *v);
  virtual TyArray *clone() const;
  void swap(TyArray &);
};

class TyVector : public Type
{
public:
  Type *type_;
  IntOrName *intorname_;

  TyVector(const TyVector &);
  TyVector &operator=(const TyVector &);
  TyVector(Type *p1, IntOrName *p2);
  ~TyVector();
  virtual void accept(Visitor *v);
  virtual TyVector *clone() const;
  void swap(TyVector &);
};

class TEType : public TemplateExp
{
public:
  Type *type_;

  TEType(const TEType &);
  TEType &operator=(const TEType &);
  TEType(Type *p1);
  ~TEType();
  virtual void accept(Visitor *v);
  virtual TEType *clone() const;
  void swap(TEType &);
};

class TEConstExp : public TemplateExp
{
public:
  Exp *exp_;

  TEConstExp(const TEConstExp &);
  TEConstExp &operator=(const TEConstExp &);
  TEConstExp(Exp *p1);
  ~TEConstExp();
  virtual void accept(Visitor *v);
  virtual TEConstExp *clone() const;
  void swap(TEConstExp &);
};

class TemplateArg1 : public TemplateArg
{
public:
  Id id_;
  TemplateExp *templateexp_;

  TemplateArg1(const TemplateArg1 &);
  TemplateArg1 &operator=(const TemplateArg1 &);
  TemplateArg1(Id p1, TemplateExp *p2);
  ~TemplateArg1();
  virtual void accept(Visitor *v);
  virtual TemplateArg1 *clone() const;
  void swap(TemplateArg1 &);
};



class ListDef : public Visitable, public std::vector<Def*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDef *clone() const;
};

class ListMetaParam : public Visitable, public std::vector<MetaParam*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListMetaParam *clone() const;
};

class ListModDef : public Visitable, public std::vector<ModDef*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListModDef *clone() const;
};

class ListEventParam : public Visitable, public std::vector<EventParam*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListEventParam *clone() const;
};

class ListEventOrList : public Visitable, public std::vector<EventOrList*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListEventOrList *clone() const;
};

class ListStructDef : public Visitable, public std::vector<StructDef*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStructDef *clone() const;
};

class ListFuncParam : public Visitable, public std::vector<FuncParam*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFuncParam *clone() const;
};

class ListStatement : public Visitable, public std::vector<Statement*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStatement *clone() const;
};

class ListBlockAttr : public Visitable, public std::vector<BlockAttr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListBlockAttr *clone() const;
};

class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};

class ListPackageName : public Visitable, public std::vector<PackageName*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListPackageName *clone() const;
};

class ListStructLiteralField : public Visitable, public std::vector<StructLiteralField*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStructLiteralField *clone() const;
};

class ListTemplateArg : public Visitable, public std::vector<TemplateArg*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListTemplateArg *clone() const;
};



#endif
