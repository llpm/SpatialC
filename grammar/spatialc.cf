PDefs.Package ::= [Def] ;

DefImport.  Def ::= "import" [PackageName] ";" ;
DefPackage. Def ::= "package" [PackageName] ";" ;
DefModule.  Def ::= "module" Id MetaParamDecl "{" [ModDef] "}" ;
DefStruct.  Def ::= "struct" Id MetaParamDecl "{" [StructDef] "}" ;
terminator Def "" ;

NoParams.   MetaParamDecl ::= ;
SomeParams. MetaParamDecl ::= "(" [MetaParam] ")" ;

EqExp.   OptionalEqExp ::= "=" Exp;
NoEqExp. OptionalEqExp ::= ;

rules MetaParam ::= Type Id OptionalEqExp ;
separator MetaParam "," ;

DefConst.   ModDef ::= "const" Type Id OptionalEqExp ";" ;
DefStorage. ModDef ::= Type Id ";" ;
DefInput.   ModDef ::= "input" Type Id ";" ;
DefOutput.  ModDef ::= "output" Type Id ";" ;
DefInternal.ModDef ::= "internal" Type Id ";" ;
DefEvent.   ModDef ::= "event" EventName "(" [EventParam] ")" Block ;
DefConnect. ModDef ::= ChannelSpecifier "->" ChannelSpecifier ";" ;
DefFor.     ModDef ::= "static_for" "(" Id ":" Exp ".." Exp ")" "{" [ModDef] "}" ;
DefIf.      ModDef ::= "static_if" "(" Exp ")" "{" [ModDef] "}" ;
terminator ModDef "" ;

SimpleCS.   ChannelSpecifier ::= Id;
DotCS.      ChannelSpecifier ::= Id "." Id ;

NoEvName.   EventName ::= ;
EvName.     EventName ::= "\"" Id "\"" ;

rules EventParam ::= EventOrCond "->" Id ;
separator EventParam "," ;

SimpleEvOr. EventOrCond ::= Id ;
SubmodEvOr. EventOrCond ::= Id "." Id ;
ListEvOr.   EventOrCond ::= "(" [EventOrList] ")" ;

SimpleOrList. EventOrList ::= Id ;
SubmodOrList. EventOrList ::= Id "." Id ;
separator EventOrList "|" ;

DefSubstor. StructDef ::= Type Id ";" ;
DefFunction.StructDef ::= Type Id "(" [FuncParam] ")" "{" [Statement] "}" ;
terminator StructDef "" ;

rules FuncParam ::= Type Id ;
separator FuncParam "," ;

VarStmt.       Statement ::= Type Id VarAssignment ;
AssignStmt.    Statement ::= Id "=" Exp ";" ;
AssignArrStmt. Statement ::= Id "[" Exp "]" "=" Exp ";" ;
IfStmt.        Statement ::= "if" "(" Exp ")" Block ElseBlock ;
BlockStmt.     Statement ::= Block;
PushStmt.      Statement ::= Id PushSubDest "<-" Exp ";" ;
StaticForStmt. Statement ::= "static_for" "(" Id ":" Exp ".." Exp ")" Block ;
StaticIfStmt.  Statement ::= "static_if" "(" Exp ")" Block ;
ReturnStmt.    Statement ::= "return" Exp ";" ;
terminator     Statement "" ;

PushSubreg. PushSubDest ::= "." Id ;
PushArray.  PushSubDest ::= "[" Exp "]" ;
PushReg.    PushSubDest ::= ;

VarAssign.  VarAssignment ::= "=" Exp ";" ;
NoVarAssign.VarAssignment ::= ;

rules Block ::= [BlockAttr] "{" [Statement] "}" ;

rules BlockAttr ::= "atomic" | "xact" ;
terminator BlockAttr "";

Else.       ElseBlock ::= "else" Block ;
NoElse.     ElseBlock ::= ;

ETrue.   Exp15  ::= "true" ;
EFalse.  Exp15  ::= "false" ;
EInt.    Exp15  ::= Integer ;
EDouble. Exp15  ::= Double ;
EString. Exp15  ::= String ;
EId.     Exp15  ::= Id ; 

EApp.    Exp15  ::= Exp15 "(" [Exp] ")" ;
EArrAcc. Exp15  ::= Exp15 "[" Exp "]" ;
EDot.    Exp15  ::= Exp15  "." Id ;

EStructLiteral. Exp14 ::= Id "{" [StructLiteralField] "}" ;
EVectorLiteral. Exp14 ::= "[" [Exp] "]" ;

ETimes.  Exp12  ::= Exp12 "*"  Exp13 ;
EDiv.    Exp12  ::= Exp12 "/"  Exp13 ;
EPlus.   Exp11  ::= Exp11 "+"  Exp12 ;
EMinus.  Exp11  ::= Exp11 "-"  Exp12 ;
ELt.     Exp9   ::= Exp9  "<"  Exp10 ;
EGt.     Exp9   ::= Exp9  ">"  Exp10 ;
ELtEq.   Exp9   ::= Exp9  "<=" Exp10 ;
EGtEq.   Exp9   ::= Exp9  ">=" Exp10 ;
EEq.     Exp8   ::= Exp8  "==" Exp9 ;
ENEq.    Exp8   ::= Exp8  "!=" Exp9 ;
EAnd.    Exp4   ::= Exp4  "&&" Exp5 ;
EOr.     Exp3   ::= Exp3  "||" Exp4 ;

coercions Exp 15;

separator Exp "," ;

rules PackageName ::= Id ;
separator PackageName "." ;

rules StructLiteralField ::= Id ":" Exp ;
separator StructLiteralField "," ;

token Id ((letter | '_') (letter | digit | '_')*) ;

ConstName. IntOrName ::= Id ;
Int.       IntOrName ::= Integer ;

TyName.      Type  ::= Id ;
TyNameParams.Type  ::= Id "!" "(" [TemplateArg] ")" ;
TyArray.     Type  ::= Type "[" IntOrName "]" ;
TyVector.    Type  ::= Type "<" IntOrName ">" ;

rules TemplateArg ::= Id "=" Exp ; 
separator TemplateArg "," ;

comment "//" ;
comment "/*" "*/" ;

entrypoints Package;
